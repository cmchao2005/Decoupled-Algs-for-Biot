"""This demo program solves the three-field Biot's equation (Coupled)

Example 1. 

data 2023 07 05
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

mu      = 1.0
lmbda   = 1.0

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

# Define boundary conditions
u_true    = Expression(("0.1*(exp(t)*(x[0]+x[1]*x[1]*x[1]))","0.1*(t*t*(x[0]*x[0]*x[0]+x[1]*x[1]*x[1]))"), degree=3, t=0.0)
p_true    = Expression("10.0*exp((x[0]+x[1])/10.0)*(1.0+t*t*t)", degree=2, t=0.0)
ksi_true  = Expression("alpha*10.0*exp((x[0]+x[1])/10.0)*(1+t*t*t)-lmbda*(0.1*exp(t)+0.3*t*t*x[1]*x[1])", 
                          degree=2, alpha=alpha, lmbda=lmbda, t=0.0)

f         = Expression(("-2*mu*(0.3*exp(t)*x[1]) + alpha*exp((x[0]+x[1])/10.0)*(1.0+t*t*t)",
                            "-2*mu*(0.3*t*t*x[0] + 0.6*t*t*x[1]) - lmbda*(0.6*t*t*x[1]) + alpha*exp((x[0]+x[1])/10.0)*(1+t*t*t)"),
                           mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g         = Expression("c0*(30*exp((x[0]+x[1])/10.0)*(t)*(t)) + alpha*(0.1*exp(t)+0.6*(t)*x[1]*x[1]) - 0.2*KK*exp((x[0]+x[1])/10.0)*(1.0+t*t*t)",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)
                     
w1_0      = Expression(("0.1*(x[0]+x[1]*x[1]*x[1])","0.0","alpha*10*exp((x[0]+x[1])/10.0)-lmbda*(0.1)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0       = Expression("10.0*exp((x[0]+x[1])/10.0)", degree=2)
w_0       = Expression(("0.1*(x[0]+x[1]*x[1]*x[1])","0.0",
                  "alpha*10*exp((x[0]+x[1])/10.0)-lmbda*(0.1)",
                  "10*exp((x[0]+x[1])/10.0)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)


def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

t = 0.0
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = inner(div(uc),phic)*dx + 1.0/lmbda*inner(ksic,phic)*dx - alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + alpha*alpha/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx 
L2c = inner(g, psic)*dx 
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    
    # Compute solution
    solve(ac == Lc, wc, bcc)
    
    (uc, ksic, pc) = wc.split(True)
    
    w_oldc.assign(wc)
    
    print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
    print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
    print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(pc)

pic = plot(pc)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, pc, 'L2')
error_H1_p  = errornorm(p_true, pc, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(pc,'L2'))
t = 0.25
error_H1_u  = 0.00829532977839973
error_L2_xi = 0.0446796541556744
error_L2_p  = 0.0480620780001963
error_H1_p  = 0.22589173783842145
t = 0.5
error_H1_u  = 0.022119717920761714
error_L2_xi = 0.11787623988271793
error_L2_p  = 0.12698753133836152
error_H1_p  = 0.594501903508087
t = 0.75
error_H1_u  = 0.03704572506440283
error_L2_xi = 0.19615415288879454
error_L2_p  = 0.2115067440171644
error_H1_p  = 0.988003019345998
t = 1.0
error_H1_u  = 0.05218665334400362
error_L2_xi = 0.27540573796517825
error_L2_p  = 0.2971014342348112
error_H1_p  = 1.3862994465213982
time cost 20.778000831604004 s
22.394412041342463

In [2]:
"""This demo program solves the three-field Biot's equation (Decoupled StR)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

mu      = 1.0
lmbda   = 1.0

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true = Expression(("0.1*(exp(t)*(x[0]+x[1]*x[1]*x[1]))","0.1*(t*t*(x[0]*x[0]*x[0]+x[1]*x[1]*x[1]))"), degree=3, t=0.0)
p_true    = Expression("10.0*exp((x[0]+x[1])/10.0)*(1.0+t*t*t)", degree=2, t=0.0)
ksi_true  = Expression("alpha*10.0*exp((x[0]+x[1])/10.0)*(1+t*t*t)-lmbda*(0.1*exp(t)+0.3*t*t*x[1]*x[1])", 
                          degree=2, alpha=alpha, lmbda=lmbda, t=0.0)

f         = Expression(("-2*mu*(0.3*exp(t)*x[1]) + alpha*exp((x[0]+x[1])/10.0)*(1.0+t*t*t)",
                            "-2*mu*(0.3*t*t*x[0] + 0.6*t*t*x[1]) - lmbda*(0.6*t*t*x[1]) + alpha*exp((x[0]+x[1])/10.0)*(1+t*t*t)"),
                           mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g         = Expression("c0*(30*exp((x[0]+x[1])/10)*(t)*(t)) + alpha*(0.1*exp(t)+0.6*(t)*x[1]*x[1]) - 0.2*KK*exp((x[0]+x[1])/10.0)*(1+(t)*(t)*(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)
g_oldd    = Expression("c0*(30*exp((x[0]+x[1])/10)*(t)*(t)) + alpha*(0.1*exp(t)+0.6*(t)*x[1]*x[1]) - 0.2*KK*exp((x[0]+x[1])/10.0)*(1+(t)*(t)*(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)                       
w1_0       = Expression(("0.1*(x[0]+x[1]*x[1]*x[1])","0.0","alpha*10*exp((x[0]+x[1])/10.0)-lmbda*(0.1)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0       = Expression("10.0*exp((x[0]+x[1])/10.0)", degree=2)
w_0       = Expression(("0.1*(x[0]+x[1]*x[1]*x[1])","0.0",
                  "alpha*10*exp((x[0]+x[1])/10.0)-lmbda*(0.1)",
                  "10*exp((x[0]+x[1])/10.0)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)


def boundary(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

bc11 = DirichletBC(Q1.sub(0), u_true, boundary)
bc22 = DirichletBC(Q2, p_true, boundary)

w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2i = - inner(div(u),phi)*dx - 1/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_,phi)*dx
a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx
L2 = inner(g, psi)*dx

# L2 = 0.5 * inner(g + g_old, psi)*dx

F1  = a1 + a2 - L1
a11, L11 = lhs(F1), rhs(F1)

F1i  = a1 + a2i - L1
a11i, L11i = lhs(F1i), rhs(F1i)

F1StR  = a1 + a2StR - L1
a11StR, L11StR = lhs(F1StR), rhs(F1StR)

F2StR  = a3 - L2
a22StR, L22StR = lhs(F2StR), rhs(F2StR)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
ksi_.assign(ksic)
p_old.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    
    # Compute solution
    solve(a11StR == L11StR, w1, bc11)
    w1_.assign(w1)
    
    solve(a22StR == L22StR, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_oldold.assign(p_old)
    p_old.assign(p)
    
    w1_old.assign(w1)
    u, ksi = w1.split(True)
    print('error_H1_u  =', errornorm(u_true, u, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
    print('error_L2_p  =', errornorm(p_true, p, 'L2'))
    print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 0.00829532977839973
error_L2_xi = 0.0446796541556744
error_L2_p  = 0.0480620780001963
error_H1_p  = 0.22589173783842145
t = 0.5
error_H1_u  = 0.01906300451156114
error_L2_xi = 1.169232277242878
error_L2_p  = 0.003718450485174379
error_H1_p  = 0.02811017960790323
t = 0.75
error_H1_u  = 0.04695505394424061
error_L2_xi = 3.2888316584864694
error_L2_p  = 0.08761473330267223
error_H1_p  = 0.412510721656163
t = 1.0
error_H1_u  = 0.09276421520235135
error_L2_xi = 6.473334258502374
error_L2_p  = 0.17691789062722774
error_H1_p  = 0.8271878758064956
time cost 16.313334703445435 s
21.98918210551093

In [3]:
"""This demo program solves the three-field Biot's equation (Decoupled RtS)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

mu      = 1.0
lmbda   = 1.0

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true = Expression(("0.1*(exp(t)*(x[0]+x[1]*x[1]*x[1]))","0.1*(t*t*(x[0]*x[0]*x[0]+x[1]*x[1]*x[1]))"), degree=3, t=0.0)
p_true    = Expression("10.0*exp((x[0]+x[1])/10.0)*(1.0+t*t*t)", degree=2, t=0.0)
ksi_true  = Expression("alpha*10.0*exp((x[0]+x[1])/10.0)*(1+t*t*t)-lmbda*(0.1*exp(t)+0.3*t*t*x[1]*x[1])", 
                          degree=2, alpha=alpha, lmbda=lmbda, t=0.0)

f         = Expression(("-2*mu*(0.3*exp(t)*x[1]) + alpha*exp((x[0]+x[1])/10.0)*(1.0+t*t*t)",
                            "-2*mu*(0.3*t*t*x[0] + 0.6*t*t*x[1]) - lmbda*(0.6*t*t*x[1]) + alpha*exp((x[0]+x[1])/10.0)*(1+t*t*t)"),
                           mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g         = Expression("c0*(30*exp((x[0]+x[1])/10.0)*(t)*(t)) + alpha*(0.1*exp(t)+0.6*(t)*x[1]*x[1]) - 0.2*KK*exp((x[0]+x[1])/10.0)*(1+(t)*(t)*(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)
g_oldd    = Expression("c0*(30*exp((x[0]+x[1])/10.0)*(t)*(t)) + alpha*(0.1*exp(t)+0.6*(t)*x[1]*x[1]) - 0.2*KK*exp((x[0]+x[1])/10.0)*(1+(t)*(t)*(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)                       
w1_0       = Expression(("0.1*(x[0]+x[1]*x[1]*x[1])","0.0","alpha*10*exp((x[0]+x[1])/10.0)-lmbda*(0.1)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0       = Expression("10.0*exp((x[0]+x[1])/10.0)", degree=2)
w_0       = Expression(("0.1*(x[0]+x[1]*x[1]*x[1])","0.0",
                  "alpha*10*exp((x[0]+x[1])/10.0)-lmbda*(0.1)",
                  "10*exp((x[0]+x[1])/10.0)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)


def boundary(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

bc11 = DirichletBC(Q1.sub(0), u_true, boundary)
bc22 = DirichletBC(Q2, p_true, boundary)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3RtS = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_old-ksi_oldold,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2RtS = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_old,phi)*dx + alpha/lmbda*inner(p_-p_old,phi)*dx

L1 = inner(f, v)*dx
L2 = inner(g, psi)*dx

F1 = a1 + a2RtS- L1
a11, L11 = lhs(F1), rhs(F1)

F2 = a3RtS - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
(u_old,ksi_old) = w1_old.split()
ksi_old.assign(ksic)
p_old.assign(pc)
p_.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    
    solve(a22 == L22, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_.assign(p)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_oldold.assign(w1_old)
    w1_old.assign(w1)
    
    p_old.assign(p)
    u, ksi = w1.split(True)
    print('error_H1_u  =', errornorm(u_true, u, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
    print('error_L2_p  =', errornorm(p_true, p, 'L2'))
    print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 0.00829532977839973
error_L2_xi = 0.0446796541556744
error_L2_p  = 0.0480620780001963
error_H1_p  = 0.22589173783842145
t = 0.5
error_H1_u  = 0.011639160475524551
error_L2_xi = 0.23268409181464533
error_L2_p  = 0.019576066583475913
error_H1_p  = 0.09663404483968036
t = 0.75
error_H1_u  = 0.025031742561300818
error_L2_xi = 0.3008484217311113
error_L2_p  = 0.0958399313961454
error_H1_p  = 0.4497194161694689
t = 1.0
error_H1_u  = 0.039071357111162816
error_L2_xi = 0.37281393013432285
error_L2_p  = 0.17531818430653404
error_H1_p  = 0.8191907499486552
time cost 15.983941555023193 s
21.99061954788018

In [16]:
"""This demo program solves the three-field Biot's equation (Coupled)

Example 2. 

data 2023 07 04
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 4
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2i = - inner(div(u),phi)*dx - 1/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_,phi)*dx
a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

# L2 = 0.5 * inner(g + g_old, psi)*dx

F1  = a1 + a2 - L1
a11, L11 = lhs(F1), rhs(F1)

F1i  = a1 + a2i - L1
a11i, L11i = lhs(F1i), rhs(F1i)

F1StR  = a1 + a2StR - L1
a11StR, L11StR = lhs(F1StR), rhs(F1StR)

F2StR  = a3 - L2
a22StR, L22StR = lhs(F2StR), rhs(F2StR)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
t = 0
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    # Compute solution
    solve(ac == Lc, wc, bcc)
    
    (uc, ksic, pc) = wc.split(True)
    
    w_oldc.assign(wc)
    
    print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
    print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
    print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(pc)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
t = 0.25
error_H1_u  = 1.1296415700843612
error_L2_xi = 0.10431335041462789
error_L2_p  = 0.052947358784110846
error_H1_p  = 0.6542531912847869
t = 0.5
error_H1_u  = 0.8796900872970278
error_L2_xi = 0.0805408870782293
error_L2_p  = 0.03588874170346511
error_H1_p  = 0.49852453089887394
t = 0.75
error_H1_u  = 0.6851302382005406
error_L2_xi = 0.06267503050189385
error_L2_p  = 0.027766484356501975
error_H1_p  = 0.38863138814570786
t = 1.0
error_H1_u  = 0.5335911268579893
error_L2_xi = 0.04878824978222259
error_L2_p  = 0.021597660286371632
error_H1_p  = 0.3028970100293482
time cost 0.08537077903747559 s
0.0

In [15]:
"""This demo program solves the three-field Biot's equation (Decoupled StR)

Example 2. 

data 2023 07 04
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 4
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2i = - inner(div(u),phi)*dx - 1/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_,phi)*dx
a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

# L2 = 0.5 * inner(g + g_old, psi)*dx

F1  = a1 + a2 - L1
a11, L11 = lhs(F1), rhs(F1)

F1i  = a1 + a2i - L1
a11i, L11i = lhs(F1i), rhs(F1i)

F1StR  = a1 + a2StR - L1
a11StR, L11StR = lhs(F1StR), rhs(F1StR)

F2StR  = a3 - L2
a22StR, L22StR = lhs(F2StR), rhs(F2StR)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
ksi_.assign(ksic)
p_old.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    # Compute solution
    solve(a11StR == L11StR, w1, bc11)
    w1_.assign(w1)
    
    solve(a22StR == L22StR, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_oldold.assign(p_old)
    p_old.assign(p)
    
    w1_old.assign(w1)
    u, ksi = w1.split(True)
    print('error_H1_u  =', errornorm(u_true, u, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
    print('error_L2_p  =', errornorm(p_true, p, 'L2'))
    print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 1.1296415700843612
error_L2_xi = 0.10431335041462789
error_L2_p  = 0.052947358784110846
error_H1_p  = 0.6542531912847869
t = 0.5
error_H1_u  = 0.8932438214251985
error_L2_xi = 0.12782986472687496
error_L2_p  = 0.05043249337300783
error_H1_p  = 0.5223386744867541
t = 0.75
error_H1_u  = 0.7084744110344943
error_L2_xi = 0.13629380748704958
error_L2_p  = 0.037098811159801
error_H1_p  = 0.3989507241360463
t = 1.0
error_H1_u  = 0.5599507980381593
error_L2_xi = 0.1249608436276313
error_L2_p  = 0.025970365920978088
error_H1_p  = 0.3052032522474617
time cost 0.09169125556945801 s
0.1644672689668728

In [18]:
"""This demo program solves the three-field Biot's equation (Decoupled RtS)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 4
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3RtS = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_old-ksi_oldold,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2RtS = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_old,phi)*dx + alpha/lmbda*inner(p_-p_old,phi)*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

F1 = a1 + a2RtS- L1
a11, L11 = lhs(F1), rhs(F1)

F2 = a3RtS - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
(u_old,ksi_old) = w1_old.split()
ksi_old.assign(ksic)
p_old.assign(pc)
p_.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    solve(a22 == L22, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_.assign(p)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_oldold.assign(w1_old)
    w1_old.assign(w1)
    
    p_old.assign(p)
    u, ksi = w1.split(True)
    print('error_H1_u  =', errornorm(u_true, u, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
    print('error_L2_p  =', errornorm(p_true, p, 'L2'))
    print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 1.1296415700843612
error_L2_xi = 0.10431335041462789
error_L2_p  = 0.052947358784110846
error_H1_p  = 0.6542531912847869
t = 0.5
error_H1_u  = 0.8982404478920872
error_L2_xi = 0.1391548843137554
error_L2_p  = 0.049559600096748674
error_H1_p  = 0.5421797560329668
t = 0.75
error_H1_u  = 0.718122497672065
error_L2_xi = 0.1548585342518029
error_L2_p  = 0.041172868736874715
error_H1_p  = 0.4248355145562336
t = 1.0
error_H1_u  = 0.5723100666641054
error_L2_xi = 0.14629583011878022
error_L2_p  = 0.034773313364398796
error_H1_p  = 0.32852266566869176
time cost 0.07679963111877441 s
0.1666974418742406

In [25]:
"""This demo program solves the three-field Biot's equation (Coupled)

Example 2. 

data 2023 07 04
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4096
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 32
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P3-P2-P2)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=3, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2i = - inner(div(u),phi)*dx - 1/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_,phi)*dx
a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

# L2 = 0.5 * inner(g + g_old, psi)*dx

F1  = a1 + a2 - L1
a11, L11 = lhs(F1), rhs(F1)

F1i  = a1 + a2i - L1
a11i, L11i = lhs(F1i), rhs(F1i)

F1StR  = a1 + a2StR - L1
a11StR, L11StR = lhs(F1StR), rhs(F1StR)

F2StR  = a3 - L2
a22StR, L22StR = lhs(F2StR), rhs(F2StR)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
t = 0
flag = 0
while t < T - dt/5.0:    
    t += dt
    flag += 1
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    # Compute solution
    solve(ac == Lc, wc, bcc)
    
    w_oldc.assign(wc)
    
    if flag%100 == 1:
        print("t =", t)
        
(uc, ksic, pc) = wc.split(True)
print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(pc)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
Calling FFC just-in-time (JIT) compiler, this may take some time.
Calling FFC just-in-time (JIT) compiler, this may take some time.
t = 0.000244140625
t = 0.024658203125
t = 0.049072265625
t = 0.073486328125
t = 0.097900390625
t = 0.122314453125
t = 0.146728515625
t = 0.171142578125
t = 0.195556640625
t = 0.219970703125
t = 0.244384765625
t = 0.268798828125
t = 0.293212890625
t = 0.317626953125
t = 0.342041015625
t = 0.366455078125
t = 0.390869140625
t = 0.415283203125
t = 0.439697265625
t = 0.464111328125
t = 0.488525390625
t = 0.512939453125
t = 0.537353515625
t = 0.561767578125
t = 0.586181640625
t = 0.610595703125
t = 0.635009765625
t = 0.659423828125
t = 0.683837890625
t = 0.708251953125
t = 0.732666015625
t = 0.757080078125
t = 0.781494140625
t = 0.805908203125
t = 0.830322265625
t = 0.854736328125
t = 0.879150390625
t = 0.903564453125
t = 0.927978515625
t = 0.952392578125
t = 0.976806640625
error_H1_u  = 0.0002227477141303808
error_L2_xi = 1.2618184006818055e-05
error_L2_p  = 5.943511538208606e-06
error_H1_p  = 0.0007720568330094555
time cost 1423.4827342033386 s
0.0

In [34]:
"""This demo program solves the three-field Biot's equation (Decoupled StR)

Example 2. 

data 2023 07 04
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4096
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 32
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=3, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2i = - inner(div(u),phi)*dx - 1/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_,phi)*dx
a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

# L2 = 0.5 * inner(g + g_old, psi)*dx

F1  = a1 + a2 - L1
a11, L11 = lhs(F1), rhs(F1)

F1i  = a1 + a2i - L1
a11i, L11i = lhs(F1i), rhs(F1i)

F1StR  = a1 + a2StR - L1
a11StR, L11StR = lhs(F1StR), rhs(F1StR)

F2StR  = a3 - L2
a22StR, L22StR = lhs(F2StR), rhs(F2StR)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
ksi_.assign(ksic)
p_old.assign(pc)
flag = 0
while t < T - dt/5.0:    
    t += dt
    flag += 1
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    # Compute solution
    solve(a11StR == L11StR, w1, bc11)
    w1_.assign(w1)
    
    solve(a22StR == L22StR, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_oldold.assign(p_old)
    p_old.assign(p)
    
    w1_old.assign(w1)
    u, ksi = w1.split(True)
    
    if flag%100 == 1:
        print("t =", t)
    
print('error_H1_u  =', errornorm(u_true, u, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
print('error_L2_p  =', errornorm(p_true, p, 'L2'))
print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 0.0006049700751442686
error_L2_xi = 3.420591251571893e-05
error_L2_p  = 9.927312339940887e-06
error_H1_p  = 0.002112086631048229
Calling FFC just-in-time (JIT) compiler, this may take some time.
Calling FFC just-in-time (JIT) compiler, this may take some time.
t = 0.00048828125
t = 0.02490234375
t = 0.04931640625
t = 0.07373046875
t = 0.09814453125
t = 0.12255859375
t = 0.14697265625
t = 0.17138671875
t = 0.19580078125
t = 0.22021484375
t = 0.24462890625
t = 0.26904296875
t = 0.29345703125
t = 0.31787109375
t = 0.34228515625
t = 0.36669921875
t = 0.39111328125
t = 0.41552734375
t = 0.43994140625
t = 0.46435546875
t = 0.48876953125
t = 0.51318359375
t = 0.53759765625
t = 0.56201171875
t = 0.58642578125
t = 0.61083984375
t = 0.63525390625
t = 0.65966796875
t = 0.68408203125
t = 0.70849609375
t = 0.73291015625
t = 0.75732421875
t = 0.78173828125
t = 0.80615234375
t = 0.83056640625
t = 0.85498046875
t = 0.87939453125
t = 0.90380859375
t = 0.92822265625
t = 0.95263671875
t = 0.97705078125
error_H1_u  = 0.00022725520624761154
error_L2_xi = 3.101945321312565e-05
error_L2_p  = 6.1096396087819575e-06
error_H1_p  = 0.000772069735814303
time cost 1115.4964392185211 s
0.1839369624068894

In [35]:
"""This demo program solves the three-field Biot's equation (Decoupled RtS)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha	= 1.0
c0	    = 1.0
KK	    = 1.0
E       = 1.0
nu      = 0.3
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4096
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 32
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=3, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3RtS = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_old-ksi_oldold,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2RtS = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_old,phi)*dx + alpha/lmbda*inner(p_-p_old,phi)*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

F1 = a1 + a2RtS- L1
a11, L11 = lhs(F1), rhs(F1)

F2 = a3RtS - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
(u_old,ksi_old) = w1_old.split()
ksi_old.assign(ksic)
p_old.assign(pc)
p_.assign(pc)
flag = 0
while t < T - dt/5.0:    
    t += dt
    flag += 1
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    solve(a22 == L22, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_.assign(p)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_oldold.assign(w1_old)
    w1_old.assign(w1)
    
    p_old.assign(p)
    u, ksi = w1.split(True)

    if flag%100 == 1:
        print("t =", t)
    
print('error_H1_u  =', errornorm(u_true, u, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
print('error_L2_p  =', errornorm(p_true, p, 'L2'))
print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 0.0006049700751442686
error_L2_xi = 3.420591251571893e-05
error_L2_p  = 9.927312339940887e-06
error_H1_p  = 0.002112086631048229
t = 0.00048828125
t = 0.02490234375
t = 0.04931640625
t = 0.07373046875
t = 0.09814453125
t = 0.12255859375
t = 0.14697265625
t = 0.17138671875
t = 0.19580078125
t = 0.22021484375
t = 0.24462890625
t = 0.26904296875
t = 0.29345703125
t = 0.31787109375
t = 0.34228515625
t = 0.36669921875
t = 0.39111328125
t = 0.41552734375
t = 0.43994140625
t = 0.46435546875
t = 0.48876953125
t = 0.51318359375
t = 0.53759765625
t = 0.56201171875
t = 0.58642578125
t = 0.61083984375
t = 0.63525390625
t = 0.65966796875
t = 0.68408203125
t = 0.70849609375
t = 0.73291015625
t = 0.75732421875
t = 0.78173828125
t = 0.80615234375
t = 0.83056640625
t = 0.85498046875
t = 0.87939453125
t = 0.90380859375
t = 0.92822265625
t = 0.95263671875
t = 0.97705078125
error_H1_u  = 0.0002499798902356987
error_L2_xi = 7.704639014678542e-05
error_L2_p  = 1.4683934882585844e-05
error_H1_p  = 0.0007745858790048139
time cost 1065.1961274147034 s
0.18393421103941268

In [15]:
"""This demo program solves the three-field Biot's equation (Coupled)

Example 2. 

data 2023 07 04
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
'''
dim     = 2
alpha	= 1.0
c0	    = 0.0
KK	    = 1e-6
E       = 1.0
nu      = 0.49999
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 4
mesh = UnitSquareMesh(nx, ny)
'''
dim     = 2
alpha	= 1.0
c0	    = 0.0
KK	    = 1e-6
E       = 1.0
nu      = 0.49999
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 16
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 8
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2i = - inner(div(u),phi)*dx - 1/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_,phi)*dx
a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

# L2 = 0.5 * inner(g + g_old, psi)*dx

F1  = a1 + a2 - L1
a11, L11 = lhs(F1), rhs(F1)

F1i  = a1 + a2i - L1
a11i, L11i = lhs(F1i), rhs(F1i)

F1StR  = a1 + a2StR - L1
a11StR, L11StR = lhs(F1StR), rhs(F1StR)

F2StR  = a3 - L2
a22StR, L22StR = lhs(F2StR), rhs(F2StR)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
t = 0
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    # Compute solution
    solve(ac == Lc, wc, bcc)
    
    (uc, ksic, pc) = wc.split(True)
    
    w_oldc.assign(wc)
    
    print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
    print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
    print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(pc)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
print(lmbda)
t = 0.0625
error_H1_u  = 0.368883688740826
error_L2_xi = 0.04108011596808668
error_L2_p  = 0.07320779512908486
error_H1_p  = 0.640328700488462
t = 0.125
error_H1_u  = 0.3465341550276713
error_L2_xi = 0.038591193902117966
error_L2_p  = 0.066663792360483
error_H1_p  = 0.570554505697296
t = 0.1875
error_H1_u  = 0.3255387113121924
error_L2_xi = 0.03625306945545113
error_L2_p  = 0.06085060993660207
error_H1_p  = 0.5150779505070125
t = 0.25
error_H1_u  = 0.30581531735689926
error_L2_xi = 0.034056605720978586
error_L2_p  = 0.05562356633663164
error_H1_p  = 0.4688436027560696
t = 0.3125
error_H1_u  = 0.28728690352021174
error_L2_xi = 0.03199321958556734
error_L2_p  = 0.05088766315943781
error_H1_p  = 0.4290759737799943
t = 0.375
error_H1_u  = 0.26988106959074337
error_L2_xi = 0.030054848084882613
error_L2_p  = 0.04657548061334598
error_H1_p  = 0.39414973420862814
t = 0.4375
error_H1_u  = 0.25352980187384355
error_L2_xi = 0.028233916838052354
error_L2_p  = 0.04263608458353088
error_H1_p  = 0.3630445200147317
t = 0.5
error_H1_u  = 0.23816920742202594
error_L2_xi = 0.026523310416965554
error_L2_p  = 0.03902912850918012
error_H1_p  = 0.3350754120789333
t = 0.5625
error_H1_u  = 0.22373926436926309
error_L2_xi = 0.024916344522955783
error_L2_p  = 0.035721517590931506
error_H1_p  = 0.3097548353300022
t = 0.625
error_H1_u  = 0.21018358739269816
error_L2_xi = 0.023406739856021916
error_L2_p  = 0.032685400907077305
error_H1_p  = 0.28671847950199403
t = 0.6875
error_H1_u  = 0.19744920738485325
error_L2_xi = 0.021988597571134607
error_L2_p  = 0.029896889974853236
error_H1_p  = 0.26568340692745096
t = 0.75
error_H1_u  = 0.18548636447513617
error_L2_xi = 0.02065637622384994
error_L2_p  = 0.027335197832744934
error_H1_p  = 0.24642301289787422
t = 0.8125
error_H1_u  = 0.17424831359171633
error_L2_xi = 0.019404870114089468
error_L2_p  = 0.024982035370845614
error_H1_p  = 0.2287512437429224
t = 0.875
error_H1_u  = 0.16369114180391978
error_L2_xi = 0.018229188942840875
error_L2_p  = 0.022821173102984104
error_H1_p  = 0.2125121731256857
t = 0.9375
error_H1_u  = 0.1537735967313541
error_L2_xi = 0.017124738701921896
error_L2_p  = 0.020838113908301134
error_H1_p  = 0.19757284511526033
t = 1.0
error_H1_u  = 0.1444569253492371
error_L2_xi = 0.016087203721910793
error_L2_p  = 0.019019842676712563
error_H1_p  = 0.1838182057774541
time cost 0.8593099117279053 s
0.0
16666.444442946286

In [13]:
"""This demo program solves the three-field Biot's equation (Decoupled StR)

Example 2. 

data 2023 07 04
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

'''
dim     = 2
alpha	= 1.0
c0	    = 0.0
KK	    = 1e-6
E       = 1.0
nu      = 0.49999
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 4
mesh = UnitSquareMesh(nx, ny)
'''
dim     = 2
alpha	= 1.0
c0	    = 0.0
KK	    = 1e-6
E       = 1.0
nu      = 0.49999
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 16
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 8
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2i = - inner(div(u),phi)*dx - 1/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_,phi)*dx
a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

# L2 = 0.5 * inner(g + g_old, psi)*dx

F1  = a1 + a2 - L1
a11, L11 = lhs(F1), rhs(F1)

F1i  = a1 + a2i - L1
a11i, L11i = lhs(F1i), rhs(F1i)

F1StR  = a1 + a2StR - L1
a11StR, L11StR = lhs(F1StR), rhs(F1StR)

F2StR  = a3 - L2
a22StR, L22StR = lhs(F2StR), rhs(F2StR)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
ksi_.assign(ksic)
p_old.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    # Compute solution
    solve(a11StR == L11StR, w1, bc11)
    w1_.assign(w1)
    
    solve(a22StR == L22StR, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_oldold.assign(p_old)
    p_old.assign(p)
    
    w1_old.assign(w1)
    u, ksi = w1.split(True)
    print('error_H1_u  =', errornorm(u_true, u, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
    print('error_L2_p  =', errornorm(p_true, p, 'L2'))
    print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 0.368883688740826
error_L2_xi = 0.04108011596808668
error_L2_p  = 0.07320779512908486
error_H1_p  = 0.640328700488462
t = 0.125
error_H1_u  = 0.3465341530947269
error_L2_xi = 0.038591131262909445
error_L2_p  = 0.030321079138454395
error_H1_p  = 0.4141737715884866
t = 0.1875
error_H1_u  = 0.32553871094731435
error_L2_xi = 0.036253097927488626
error_L2_p  = 0.02740961697249997
error_H1_p  = 0.3787294257407022
t = 0.25
error_H1_u  = 0.3058153161721386
error_L2_xi = 0.03405663132962164
error_L2_p  = 0.025109714450336527
error_H1_p  = 0.350162624153709
t = 0.3125
error_H1_u  = 0.2872869017699262
error_L2_xi = 0.03199324412581563
error_L2_p  = 0.023339365713910463
error_H1_p  = 0.32585637935120115
t = 0.375
error_H1_u  = 0.26988106743505286
error_L2_xi = 0.030054872630722818
error_L2_p  = 0.02203578343261272
error_H1_p  = 0.3046334554464194
t = 0.4375
error_H1_u  = 0.25352979941719417
error_L2_xi = 0.028233942031832496
error_L2_p  = 0.021138252241907438
error_H1_p  = 0.28586614519434
t = 0.5
error_H1_u  = 0.2381692047352435
error_L2_xi = 0.026523336638386248
error_L2_p  = 0.020583451954872017
error_H1_p  = 0.2691610561781945
t = 0.5625
error_H1_u  = 0.22373926150231566
error_L2_xi = 0.0249163719883945
error_L2_p  = 0.02030666366515061
error_H1_p  = 0.2542380502565605
t = 0.625
error_H1_u  = 0.2101835843822184
error_L2_xi = 0.02340676867838059
error_L2_p  = 0.020245382314295148
error_H1_p  = 0.24087904612397704
t = 0.6875
error_H1_u  = 0.19744920425866394
error_L2_xi = 0.021988627796783646
error_L2_p  = 0.0203429349255428
error_H1_p  = 0.22890402794068804
t = 0.75
error_H1_u  = 0.18548636125503584
error_L2_xi = 0.020656407855968922
error_L2_p  = 0.020550807225389874
error_H1_p  = 0.21815865945769145
t = 0.8125
error_H1_u  = 0.17424831029523716
error_L2_xi = 0.01940490312773739
error_L2_p  = 0.020829422522196748
error_H1_p  = 0.208507351063752
t = 0.875
error_H1_u  = 0.1636911384454735
error_L2_xi = 0.01822922329488173
error_L2_p  = 0.021147735713231468
error_H1_p  = 0.19982913503023542
t = 0.9375
error_H1_u  = 0.15377359332299734
error_L2_xi = 0.017124774337679026
error_L2_p  = 0.021482168664032793
error_H1_p  = 0.1920150999646585
t = 1.0
error_H1_u  = 0.14445692190120116
error_L2_xi = 0.01608724057969708
error_L2_p  = 0.02181531608698135
error_H1_p  = 0.18496673564817082
time cost 0.4239034652709961 s
0.16680107951124812

In [14]:
"""This demo program solves the three-field Biot's equation (Decoupled RtS)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
set_log_level(40)

time_start = time.time()

'''
dim     = 2
alpha	= 1.0
c0	    = 0.0
KK	    = 1e-6
E       = 1.0
nu      = 0.49999
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 4
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 4
mesh = UnitSquareMesh(nx, ny)
'''
dim     = 2
alpha	= 1.0
c0	    = 0.0
KK	    = 1e-6
E       = 1.0
nu      = 0.49999
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)

T       = 1.0
stepnum = 16
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 8
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true   = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2.0*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(sin(2*pi*x[0])*( 1-cos(2.0*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)"),
                          mu=mu, lmbda=lmbda, degree=3, t=0.0)
ksi_true = Expression("alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_true   = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
    
f        = Expression(("( 8.0*mu*pi*pi*sin(2.0*pi*x[1])*cos(2*pi*x[0])-4.0*mu*pi*pi*sin(2*pi*x[1]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*cos(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                           "(-8.0*mu*pi*pi*sin(2.0*pi*x[0])*cos(2*pi*x[1])+4.0*mu*pi*pi*sin(2*pi*x[0]) + pi*pi*(3.0*mu+lmbda)/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1])-pi*pi*cos(pi*x[0])*cos(pi*x[1]) + alpha*pi*sin(pi*x[0])*cos(pi*x[1]))*exp(-t)"),
                          mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
g        = Expression("(-c0+2*pi*pi*KK)*sin(pi*x[0])*sin(pi*x[1])*exp(-(t)) - alpha*pi/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-(t))",
                          mu=mu, c0=c0, alpha=alpha, lmbda=lmbda, KK=KK, degree=2, t=0.0)

w1_0     = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)"),mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)
p_0      = Expression("sin(pi*x[0])*sin(pi*x[1])*exp(-t)", degree=2, t=0.0)
w_0      = Expression(("(sin(2.0*pi*x[1])*(-1.0+cos(2*pi*x[0]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "(sin(2.0*pi*x[0])*( 1.0-cos(2*pi*x[1]))+1.0/(mu+lmbda)*sin(pi*x[0])*sin(pi*x[1]))*exp(-t)",
                        "alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t)-pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)",
                        "sin(pi*x[0])*sin(pi*x[1])*exp(-t)"), mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

g2n2    = Expression("(pi*KK*sin(pi*x[0])*cos(pi*x[1])*exp(-(t)))* ( -2.0*x[1]+1.0 )", KK=KK, degree=2, t=0.0)
h       = Expression(("((2*mu*pi*(cos(2*pi*x[0])-cos(2*pi*x[1]))+mu*pi/(mu+lmbda)*sin(pi*(x[0]+x[1])))*exp(-t) )* ( -2.0*x[1]+1.0 )",
                      "(4*mu*pi*sin(2*pi*x[0])*sin(2*pi*x[1])*exp(-t)+2*mu*pi/(mu+lmbda)*sin(pi*x[0])*cos(pi*x[1])*exp(-t)+pi*lmbda/(mu+lmbda)*sin(pi*(x[0]+x[1]))*exp(-t)-alpha*sin(pi*x[0])*sin(pi*x[1])*exp(-t))*( -2.0*x[1]+1.0 )"),
                     mu=mu, alpha=alpha, lmbda=lmbda, degree=2, t=0.0)

def boundary1(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS 

def boundary2(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

'''
bc1 = DirichletBC(Q.sub(0), u_true, boundary1)
bc2 = DirichletBC(Q.sub(2), p_true, boundary1)
bc = [bc1, bc2]
'''

bc11 = DirichletBC(Q1.sub(0), u_true, boundary1)
bc22 = DirichletBC(Q2, p_true, boundary1)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3RtS = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_old-ksi_oldold,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2RtS = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_old,phi)*dx + alpha/lmbda*inner(p_-p_old,phi)*dx

L1 = inner(f, v)*dx - inner(h, v)*ds
L2 = inner(g, psi)*dx - inner(g2n2, psi)*ds

F1 = a1 + a2RtS- L1
a11, L11 = lhs(F1), rhs(F1)

F2 = a3RtS - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt
u_true.t = t
p_true.t = t
ksi_true.t = t
f.t = t
g.t = t
h.t = t
g2n2.t = t

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c = DirichletBC(Qc.sub(0), u_true, boundary1)
bc2c = DirichletBC(Qc.sub(2), p_true, boundary1)
bcc  = [bc1c, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx - inner(h, vc)*ds
L2c = inner(g, psic)*dx - inner(g2n2, psic)*ds
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
solve(ac == Lc, wc, bcc)
    
(uc, ksic, pc) = wc.split(True)

print('error_H1_u  =', errornorm(u_true, uc, 'H1'))
print('error_L2_xi =', errornorm(ksi_true, ksic, 'L2'))
print('error_L2_p  =', errornorm(p_true, pc, 'L2'))
print('error_H1_p  =', errornorm(p_true, pc, 'H1'))

(u_,ksi_) = w1_.split()
(u_old,ksi_old) = w1_old.split()
ksi_old.assign(ksic)
p_old.assign(pc)
p_.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Update boundary conditions
    u_true.t = t
    p_true.t = t
    ksi_true.t = t
    f.t = t
    g.t = t
    h.t = t
    g2n2.t = t
    
    solve(a22 == L22, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_.assign(p)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_oldold.assign(w1_old)
    w1_old.assign(w1)
    
    p_old.assign(p)
    u, ksi = w1.split(True)
    print('error_H1_u  =', errornorm(u_true, u, 'H1'))
    print('error_L2_xi =', errornorm(ksi_true, ksi, 'L2'))
    print('error_L2_p  =', errornorm(p_true, p, 'L2'))
    print('error_H1_p  =', errornorm(p_true, p, 'H1'))

time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(p)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
error_H1_u  = 0.368883688740826
error_L2_xi = 0.04108011596808668
error_L2_p  = 0.07320779512908486
error_H1_p  = 0.640328700488462
t = 0.125
error_H1_u  = 0.34653415016612826
error_L2_xi = 0.03859104124835224
error_L2_p  = 0.18393525094329183
error_H1_p  = 1.2724957686809169
t = 0.1875
error_H1_u  = 0.32553870774310206
error_L2_xi = 0.0362530132793072
error_L2_p  = 0.11818609271056403
error_H1_p  = 0.8087303054682845
t = 0.25
error_H1_u  = 0.30581531268863654
error_L2_xi = 0.03405655123741478
error_L2_p  = 0.1043475417800292
error_H1_p  = 0.7020765552814012
t = 0.3125
error_H1_u  = 0.28728689799894797
error_L2_xi = 0.03199316793034153
error_L2_p  = 0.09186888928596486
error_H1_p  = 0.6135921201276241
t = 0.375
error_H1_u  = 0.26988106338279
error_L2_xi = 0.03005479983881549
error_L2_p  = 0.08058075256075581
error_H1_p  = 0.5386721060250806
t = 0.4375
error_H1_u  = 0.2535297950972288
error_L2_xi = 0.02823387225581453
error_L2_p  = 0.07035758042714477
error_H1_p  = 0.4744872231078832
t = 0.5
error_H1_u  = 0.2381692001647021
error_L2_xi = 0.026523269560976025
error_L2_p  = 0.061102337111341186
error_H1_p  = 0.419178521519469
t = 0.5625
error_H1_u  = 0.22373925669975195
error_L2_xi = 0.024916307341731763
error_L2_p  = 0.05273983215900928
error_H1_p  = 0.37146017114464874
t = 0.625
error_H1_u  = 0.2101835793664567
error_L2_xi = 0.0234067062310566
error_L2_p  = 0.045213906146327816
error_H1_p  = 0.33040673052903136
t = 0.6875
error_H1_u  = 0.19744919904817748
error_L2_xi = 0.021988567345520574
error_L2_p  = 0.038487387556669195
error_H1_p  = 0.2953293006808316
t = 0.75
error_H1_u  = 0.18548635586762374
error_L2_xi = 0.020656349220073575
error_L2_p  = 0.03254459572365407
error_H1_p  = 0.2656948173511526
t = 0.8125
error_H1_u  = 0.1742483047478752
error_L2_xi = 0.019404846145251217
error_L2_p  = 0.027396396196337377
error_H1_p  = 0.2410657558075069
t = 0.875
error_H1_u  = 0.16369113275425665
error_L2_xi = 0.018229167819800912
error_L2_p  = 0.02308678408224129
error_H1_p  = 0.2210496810206504
t = 0.9375
error_H1_u  = 0.15377358750313702
error_L2_xi = 0.017124720237868353
error_L2_p  = 0.019695557491259428
error_H1_p  = 0.20525616252075193
t = 1.0
error_H1_u  = 0.14445691596705337
error_L2_xi = 0.01608718773526808
error_L2_p  = 0.017321529448634992
error_H1_p  = 0.1932645742366305
time cost 0.43119287490844727 s
0.17434981020059326

In [47]:
"""This demo program solves the three-field Biot's equation (Coupled)

Example 3.  Barry-Mercer's Problem

data 2023 07 05
"""

from dolfin import *
import time
import numpy as np
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha   = 1.0
c0      = 0.0
KK      = 1e-2
E       = 1e5
nu      = 0.1
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)
beta    = (lmbda + 2*mu)*KK

T       = np.pi/2.0/beta
stepnum = 10
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

# Define boundary conditions
u_true    = Expression(("0.0","0.0"), degree=3, t=0.0)
u1_true   = Expression("0.0", degree=3, t=0.0)
u2_true   = Expression("0.0", degree=3, t=0.0)
p_true    = Expression("0.0", degree=2, t=0.0)
ksi_true  = Expression("0.0", degree=2, t=0.0)

f         = Expression(("0.0","0.0"), degree=2, t=0.0)
g         = Expression("0.0", degree=2, t=0.0)

w1_0      = Expression(("0.0","0.0","0.0"), degree=2, t=0.0)
p_0       = Expression("0.0", degree=2, t=0.0)
w_0       = Expression(("0.0","0.0","0.0","0.0"), degree=2, t=0.0)

def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

def boundary_u2(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

def boundary_u1(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

def boundary_p(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

# Here we try to use the Coupled algorithm to solve the Barry-Mercer's Problem
Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)

bc1c1 = DirichletBC(Qc.sub(0).sub(0), 0.0, boundary_u1)
bc1c2 = DirichletBC(Qc.sub(0).sub(1), 0.0, boundary_u2)
bc2c = DirichletBC(Qc.sub(2), 0.0, boundary_p)
bcc  = [bc1c1, bc1c2, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2.0*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1.0/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + alpha*alpha/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution

t = 0.0
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    A_ass, b_ass = assemble_system(lhs(Fc), rhs(Fc), bcc)

    ps = PointSource(Qc.sub(2), Point(0.25,0.25), 2.0*beta*np.sin(beta*t))
    ps.apply(b_ass)

    solve(A_ass, wc.vector(), b_ass)
    
    w_oldc.assign(wc)
    
(uc, ksic, pc) = wc.split(True)
# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(pc)

pic = plot(uc)
pyplot.colorbar(pic)
t = 0.00015358897417550103
Calling FFC just-in-time (JIT) compiler, this may take some time.
Calling FFC just-in-time (JIT) compiler, this may take some time.
t = 0.00030717794835100206
t = 0.0004607669225265031
t = 0.0006143558967020041
t = 0.0007679448708775051
t = 0.0009215338450530061
t = 0.001075122819228507
t = 0.001228711793404008
t = 0.001382300767579509
t = 0.00153588974175501
Out[47]:
<matplotlib.colorbar.Colorbar at 0x7fe5d2631e90>

In [48]:
print(np.max(pc.vector().get_local()))

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values1.append(pc(Point(0.036,yy)))
    y_values2.append(pc(Point(0.107,yy)))
    y_values3.append(pc(Point(0.179,yy)))
    y_values4.append(pc(Point(0.250,yy)))

fig, ax = plt.subplots()
plt.plot(x_values, y_values1, 'o-', label='$y=0.036$')
plt.plot(x_values, y_values2, '*-', label='$y=0.107$')
plt.plot(x_values, y_values3, '^-', label='$y=0.179$')
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(uc.sub(0)(Point(0.250,yy)))

print(np.min(y_values4))
    
fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(uc.sub(1)(Point(0.250,yy)))

print(np.min(y_values4))
    
fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)
153450.47129142884

[0.0, 3216.6015768694483, 6468.335452308252, 9791.881998774792, 13227.214084575897, 16819.780843331242, 20623.489757339747, 24705.080680739273, 29150.963554133024, 34078.61597631426, 39657.016825645354, 46146.73268900501, 53988.20005350825, 64026.43146968265, 78185.35792125853, 101846.28413974684, 153450.47129142884, 102783.2701488007, 80064.29051856881, 66857.28451196346, 57786.06738957997, 50931.99160296242, 45455.55247513162, 40922.11290569583, 37077.27255961682, 33758.672050603105, 30856.00743041904, 28290.716637516547, 26004.727294242093, 23953.798001404935, 22103.36847387006, 20425.86291812285, 18898.876105474115, 17503.91700935909, 16225.516430649159, 15050.579023888964, 13967.903475135001, 12967.82086770479, 12041.917705875743, 11182.82061754129, 10384.026691519162, 9639.768058781438, 8944.902508032566, 8294.824136989304, 7685.38960036554, 7112.85663067944, 6573.832315090352, 6065.229202200983, 5584.227749619571, 5128.243949266873, 4694.9012131746285, 4282.005789267027, 3887.525119662732, 3509.5686644446823, 3146.3707996763023, 2796.2754656114303, 2457.7222939246412, 2129.233984633543, 1809.4047366299626, 1496.8895622141747, 1190.3943371174237, 888.6664542480565, 590.4859625958932, 294.6570829729687, 1.570051298959911e-14]
-0.021236092746671487

[6.943870026570695e-20, -0.0013796393457558656, -0.0027530845626919, -0.004113740095135691, -0.0054551254630405355, -0.0067709045078118025, -0.008054919145270586, -0.00930122213258162, -0.010504101454410579, -0.011658086000222575, -0.01275790835150678, -0.013798360689583103, -0.014773854652627077, -0.015677128957815402, -0.016495347156215433, -0.017199094138998748, -0.018095755321299017, -0.018919055905628285, -0.019403275501805414, -0.019857453960091698, -0.02025490461627154, -0.020586551226460133, -0.02084986758006619, -0.021044905776602865, -0.021172924176730036, -0.021235859966081246, -0.021236092746671487, -0.02117631247797221, -0.021059430059390177, -0.02088850838784261, -0.020666705314215224, -0.02039722494092951, -0.020083275674441747, -0.019728034245414732, -0.019334615220249818, -0.018906045629502356, -0.018445244353218676, -0.017955005886436833, -0.017437988086080585, -0.01689670348484412, -0.016333513752684197, -0.015750626892761386, -0.01515009677481237, -0.01453382463293723, -0.013903562184384603, -0.013260916058983213, -0.012607353263547044, -0.011944207440370102, -0.011272685712673862, -0.010593875941751383, -0.009908754250024765, -0.009218192690989436, -0.008522966970933347, -0.007823764148407807, -0.007121190255798272, -0.006415777803178559, -0.005707993138139812, -0.0049982436466973965, -0.004286884789917803, -0.003574226978778852, -0.0028605422961966867, -0.0021460710806244752, -0.0014310283907427524, -0.0007156106424246277, 1.9874078175710532e-20]
-0.05405579690460371

[-0.05405579690460371, -0.05398273606126123, -0.05376259800904707, -0.05339056405507719, -0.052858247905189, -0.052153462570662036, -0.051259714944827374, -0.05015542704243629, -0.04881274873128561, -0.04719570934034339, -0.045257227659644364, -0.04293399061802553, -0.040136930059288166, -0.03673127470987305, -0.032487948969960205, -0.026917345981186693, -0.01809575532130064, -0.009276073872163325, -0.0037109991235477913, 0.0005237806374419362, 0.003918884851711303, 0.006704828818490286, 0.009018273145732756, 0.010950654552259662, 0.012568171089231507, 0.013921350836535664, 0.015050227874163803, 0.01598739727634817, 0.01675994032685144, 0.017390702586518918, 0.01789917967479105, 0.018302154287188052, 0.018614169398492638, 0.018847890011140782, 0.01901438681963499, 0.019123363670294165, 0.019183343519382105, 0.019201822992010474, 0.01918540262887361, 0.019139897893868718, 0.019070434647954063, 0.018981531851632334, 0.01887717359881052, 0.018760872116529617, 0.01863572302746014, 0.018504453924520648, 0.018369467122079545, 0.01823287730728189, 0.018096544705324263, 0.01796210428517897, 0.017830991461259386, 0.017704464687582796, 0.017583625291164997, 0.01746943484857499, 0.01736273037229281, 0.017264237540651813, 0.017174582175919134, 0.017094300148767883, 0.017023845863854584, 0.016963599458816765, 0.016913872832136228, 0.016874914586228956, 0.01684691401304481, 0.016830004155918104, 0.01682427338816445]
In [49]:
"""This demo program solves the three-field Biot's equation (Decoupled StR)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
import numpy as np
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha   = 1.0
c0      = 0.0
KK      = 1e-2
E       = 1e5
nu      = 0.1
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)
beta    = (lmbda + 2*mu)*KK

T       = np.pi/2.0/beta
stepnum = 10
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true    = Expression(("0.0","0.0"), degree=3, t=0.0)
u1_true   = Expression("0.0", degree=3, t=0.0)
u2_true   = Expression("0.0", degree=3, t=0.0)
p_true    = Expression("0.0", degree=2, t=0.0)
ksi_true  = Expression("0.0", degree=2, t=0.0)

f         = Expression(("0.0","0.0"), degree=2, t=0.0)
g         = Expression("0.0", degree=2, t=0.0)

w1_0      = Expression(("0.0","0.0","0.0"), degree=2, t=0.0)
p_0       = Expression("0.0", degree=2, t=0.0)
w_0       = Expression(("0.0","0.0","0.0","0.0"), degree=2, t=0.0)

def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

def boundary_u2(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

def boundary_u1(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

def boundary_p(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

bc111 = DirichletBC(Q1.sub(0).sub(0), 0.0, boundary_u1)
bc112 = DirichletBC(Q1.sub(0).sub(1), 0.0, boundary_u2)
bc11 = [bc111, bc112]
bc22 = DirichletBC(Q2, p_true, boundary_p)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx
L2 = inner(g, psi)*dx

F1  = a1 + a2StR - L1
a11, L11 = lhs(F1), rhs(F1)

F2  = a3 - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c1 = DirichletBC(Qc.sub(0).sub(0), 0.0, boundary_u1)
bc1c2 = DirichletBC(Qc.sub(0).sub(1), 0.0, boundary_u2)
bc2c = DirichletBC(Qc.sub(2), 0.0, boundary_p)
bcc  = [bc1c1, bc1c2, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
# solve(ac == Lc, wc, bcc)
A_ass, b_ass = assemble_system(ac, Lc, bcc)
ps = PointSource(Qc.sub(2), Point(0.25,0.25), 2*beta*np.sin(beta*t))
ps.apply(b_ass)
solve(A_ass, wc.vector(), b_ass)
    
(uc, ksic, pc) = wc.split(True)

(u_,ksi_) = w1_.split()
ksi_.assign(ksic)
p_old.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_.assign(w1)
    
    A_ass1, b_ass1 = assemble_system(a22, L22, bc22)
    ps = PointSource(Q2, Point(0.25,0.25), 2*beta*np.sin(beta*t))
    ps.apply(b_ass1)
    solve(A_ass1, p.vector(), b_ass1)
    
    #solve(a22 == L22, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_oldold.assign(p_old)
    p_old.assign(p)
    
    w1_old.assign(w1)
    u, ksi = w1.split(True)
    
time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

pic = plot(u)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
print(np.max(pc.vector().get_local()))
t = 0.00030717794835100206
Calling FFC just-in-time (JIT) compiler, this may take some time.
Calling FFC just-in-time (JIT) compiler, this may take some time.
t = 0.0004607669225265031
t = 0.0006143558967020041
t = 0.0007679448708775051
t = 0.0009215338450530061
t = 0.001075122819228507
t = 0.001228711793404008
t = 0.001382300767579509
t = 0.00153588974175501
time cost 5.218196630477905 s
16055.016767212648
23048.474999424394

In [50]:
print(np.max(pc.vector().get_local()))

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(p(Point(0.250,yy)))

fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(u.sub(0)(Point(0.250,yy)))

print(np.min(y_values4))
    
fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(u.sub(1)(Point(0.250,yy)))

print(np.min(y_values4))
    
fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)
23048.474999424394

[0.0, 3333.962733759207, 6702.740401333866, 10142.691907205199, 13693.455556526027, 17400.12566401273, 21316.226665139176, 25508.077908054966, 30061.620216276424, 35093.79934551655, 40772.9807772086, 47359.00944402064, 55291.45105335408, 65414.2289069175, 79649.82914447266, 103377.41535664373, 155034.28709826845, 104400.39624756394, 81700.72531981103, 68502.96113776883, 59433.03176164038, 52573.70395106216, 47086.52875457103, 42537.70249421777, 38673.50438272141, 35332.14057510409, 32403.784259106, 29810.27970747092, 27493.902821899108, 25410.71204202528, 23526.405975437272, 21813.632775320944, 20250.1811225291, 18817.727949629658, 17500.949516156026, 16286.876379232752, 15164.41610572358, 14123.993833421302, 13157.277205731847, 12256.962743406633, 11416.607643014951, 10630.495639138511, 9893.528743713794, 9201.138883265648, 8549.215011602222, 7934.042388402232, 7352.251519381017, 6800.774842928507, 6276.809683689338, 5777.786318649626, 5301.340246109273, 4845.287933836507, 4407.605465020731, 3986.409610407464, 3579.940940261974, 3186.5486564723274, 2804.6768775349997, 2432.852150615561, 2069.6719977745597, 1713.7943296221108, 1363.9275804933825, 1018.8214357639837, 677.2580349375866, 338.04354423125045, 1.7999335028691466e-14]
-0.022397428485564645

[7.219745850184808e-20, -0.0014431506315405326, -0.002879915146123133, -0.004303504501041136, -0.0057072464081008864, -0.007084615916446512, -0.008429270118492822, -0.00973508198120294, -0.010996165852766774, -0.012206884434041339, -0.013361813327156203, -0.014455599967139125, -0.015482530133072995, -0.016435252832534792, -0.017300927943428066, -0.01805036118058374, -0.018987027290969943, -0.019847782031472878, -0.020370045714231323, -0.02085897790823652, -0.02128816322744637, -0.02164859198981552, -0.021937737885721148, -0.02215563561688732, -0.022303525463325778, -0.022383331732690165, -0.022397428485564645, -0.022348508229378, -0.022239492672622766, -0.022073463673412317, -0.02185360593284882, -0.02158315793629284, -0.02126536958982573, -0.020903465785585496, -0.020500615434352, -0.020059905602145097, -0.019584320399967044, -0.01907672425749856, -0.01853984918832413, -0.017976285637567646, -0.01738847649687721, -0.016778713877034248, -0.01614913824378856, -0.01550173954578001, -0.01483835999234283, -0.01416069817147042, -0.013470314232392016, -0.012768635891575852, -0.012056965054366762, -0.011336484876062381, -0.010608267115480196, -0.00987327966065445, -0.009132394130092649, -0.008386393474026291, -0.007635979518411197, -0.00688178041024405, -0.006124357936266866, -0.005364214698555731, -0.004601801140051006, -0.003837522420982979, -0.0030717451535921827, -0.002304804008106114, -0.0015370082083374296, -0.0007686482616168684, 2.1347025945087728e-20]
-0.055408883955444396

[-0.055408883955444396, -0.05533292338828128, -0.055104159592575704, -0.05471786139510934, -0.05416578549283027, -0.053435952789881, -0.05251215197518023, -0.051373173957157146, -0.049991643887594216, -0.048332201511706495, -0.04634855564216936, -0.04397843583092352, -0.04113419967279355, -0.037683149034154505, -0.03339955578851475, -0.027800532049443636, -0.018987027290971292, -0.010173315383818177, -0.004573470923626187, -0.00028784250354408497, 0.0031674694652213536, 0.006019631156936781, 0.008403227184578905, 0.010408263883757938, 0.012099889543143677, 0.013527831668319733, 0.014731498855463017, 0.015742989979691882, 0.016588989072625744, 0.017292022190565793, 0.017871327739413745, 0.018343481830714325, 0.018722862440287046, 0.019022003983448492, 0.019251875187349613, 0.01942210180608864, 0.019541148647476837, 0.019616470844810985, 0.019654641335481025, 0.019661459524459846, 0.019642044764381965, 0.01960091735640145, 0.019542069127809494, 0.01946902518277936, 0.01938489809168304, 0.01929243554214696, 0.01919406229433798, 0.019091917145497496, 0.018987885501870926, 0.01888362807124324, 0.018780606120294304, 0.018680103683767012, 0.018583247064081754, 0.018491021918480406, 0.018404288194574063, 0.018323793143230755, 0.01825018260930063, 0.018184010775049563, 0.01812574850819959, 0.018075790444557708, 0.018034460918748895, 0.018002018827914135, 0.01797866155749813, 0.017964528026919717, 0.017959712270519852]
In [33]:
"""This demo program solves the three-field Biot's equation (Decoupled RtS)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
import numpy as np
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model

dim     = 2
alpha   = 1.0
c0      = 0.0
KK      = 1e-2
E       = 1e5
nu      = 0.1
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)
beta    = (lmbda + 2*mu)*KK

T       = np.pi/2.0/beta
stepnum = 10
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 2)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true    = Expression(("0.0","0.0"), degree=3, t=0.0)
u1_true   = Expression("0.0", degree=3, t=0.0)
u2_true   = Expression("0.0", degree=3, t=0.0)
p_true    = Expression("0.0", degree=2, t=0.0)
ksi_true  = Expression("0.0", degree=2, t=0.0)

f         = Expression(("0.0","0.0"), degree=2, t=0.0)
g         = Expression("0.0", degree=2, t=0.0)

w1_0      = Expression(("0.0","0.0","0.0"), degree=2, t=0.0)
p_0       = Expression("0.0", degree=2, t=0.0)
w_0       = Expression(("0.0","0.0","0.0","0.0"), degree=2, t=0.0)

def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

def boundary_u2(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

def boundary_u1(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

def boundary_p(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

bc111 = DirichletBC(Q1.sub(0).sub(0), 0.0, boundary_u1)
bc112 = DirichletBC(Q1.sub(0).sub(1), 0.0, boundary_u2)
bc11 = [bc111, bc112]
bc22 = DirichletBC(Q2, p_true, boundary_p)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3RtS = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_old-ksi_oldold,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2RtS = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_old,phi)*dx + alpha/lmbda*inner(p_-p_old,phi)*dx

L1 = inner(f, v)*dx
L2 = inner(g, psi)*dx

F1 = a1 + a2RtS- L1
a11, L11 = lhs(F1), rhs(F1)

F2 = a3RtS - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c1 = DirichletBC(Qc.sub(0).sub(0), 0.0, boundary_u1)
bc1c2 = DirichletBC(Qc.sub(0).sub(1), 0.0, boundary_u2)
bc2c = DirichletBC(Qc.sub(2), 0.0, boundary_p)
bcc  = [bc1c1, bc1c2, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
# solve(ac == Lc, wc, bcc)
A_ass, b_ass = assemble_system(ac, Lc, bcc)
ps = PointSource(Qc.sub(2), Point(0.25,0.25), 2*beta*np.sin(beta*t))
ps.apply(b_ass)
solve(A_ass, wc.vector(), b_ass)
    
(uc, ksic, pc) = wc.split(True)

(u_,ksi_) = w1_.split()
(u_old,ksi_old) = w1_old.split()
ksi_old.assign(ksic)
p_old.assign(pc)
p_.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # solve(a22 == L22, p, bc22)
    # print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    A_ass1, b_ass1 = assemble_system(a22, L22, bc22)
    ps = PointSource(Q2, Point(0.25,0.25), 2*beta*np.sin(beta*t))
    ps.apply(b_ass1)
    solve(A_ass1, p.vector(), b_ass1)
    
    p_.assign(p)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_oldold.assign(w1_old)
    w1_old.assign(w1)
    
    p_old.assign(p)
    u, ksi = w1.split(True)
    
time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(p)

# pic = plot(uc)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
print(np.max(pc.vector().get_local()))
t = 0.00030717794835100206
t = 0.0004607669225265031
t = 0.0006143558967020041
t = 0.0007679448708775051
t = 0.0009215338450530061
t = 0.001075122819228507
t = 0.001228711793404008
t = 0.001382300767579509
t = 0.00153588974175501
time cost 4.746801137924194 s
16256.506219850718
23048.474999424394

In [52]:
print(np.max(pc.vector().get_local()))

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(p(Point(0.250,yy)))

fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(u.sub(0)(Point(0.250,yy)))

print(np.min(y_values4))
    
fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values4.append(u.sub(1)(Point(0.250,yy)))

print(np.min(y_values4))
    
fig, ax = plt.subplots()
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()
print(y_values4)
23048.474999424394

[0.0, 3350.397115114588, 6735.599820770952, 10191.957972437523, 13759.100001873687, 17482.109141495912, 21414.497182630523, 25622.56895465187, 30192.248622051975, 35240.46292799452, 40935.555830129604, 47537.34812518236, 55485.37872760383, 65623.54149797035, 79874.29054546411, 103616.75494464241, 155288.1973928564, 104668.53074849794, 81982.69655407076, 68798.33894220444, 59741.34182407467, 52894.42663014008, 47419.09819682637, 42881.50606555178, 39027.882430465164, 35696.38653572645, 32777.145125126845, 30191.956865012256, 27883.0532674236, 25806.449983140734, 23927.80481625264, 22219.727481860304, 20659.97095833798, 19230.179566163933, 17915.000377058765, 16701.438492401794, 15578.38003235218, 14536.232939124064, 13566.65211557649, 12662.32596024684, 11816.808287005226, 11024.384265715047, 10279.962197615938, 9578.985147290923, 8917.35801064897, 8291.386711854813, 7697.727027916508, 7133.341129248118, 6595.460360376364, 6081.553110205727, 5589.296866105081, 5116.553731923132, 4661.34883218913, 4221.851134270112, 3796.356305196787, 3383.271286159246, 2981.10031969244, 2588.4322055841444, 2203.928593990397, 1826.3131499767478, 1454.3614441102711, 1086.8914398615382, 722.7544612362652, 360.8265338454283, 1.9200155203971836e-14]
-0.021076803196679882

[6.6456177680517e-20, -0.001339986836119607, -0.0026741868629182684, -0.003996461552466525, -0.005300775492698601, -0.006581224462346359, -0.007832066576715965, -0.00904775282356226, -0.010222950445722124, -0.01135255044035866, -0.01243163877027191, -0.01345537732620872, -0.014418635147534116, -0.015314901010240807, -0.016132995541724277, -0.016847795512479908, -0.017718320823822593, -0.018519622440838122, -0.019027252938323528, -0.01950172931243501, -0.01992039800680083, -0.020275484687200265, -0.020564768387784614, -0.020788232332037096, -0.02094690615215453, -0.02104241989716826, -0.021076803196679882, -0.021052372257238224, -0.02097165271912754, -0.02083731973022703, -0.020652148044240797, -0.020418969175426297, -0.020140634298549318, -0.019819982251111666, -0.019459812252189575, -0.01906286103362574, -0.01863178408756921, -0.018169140716715132, -0.017677382552078822, -0.017158845187521827, -0.016615742574111143, -0.016050163821163976, -0.01546407206337796, -0.014859305072983093, -0.014237577320413081, -0.013600483214730001, -0.012949501284332978, -0.012285999088024887, -0.011611238675289522, -0.010926382441914776, -0.010232499252398787, -0.009530570723613184, -0.008821497584845461, -0.008106106047601295, -0.0073851541344985, -0.006659337930372206, -0.0059292977305070915, -0.0051956240709061935, -0.004458863633880122, -0.003719525029161902, -0.00297808445640162, -0.0022349912598830205, -0.001490673391497661, -0.0007455431714860744, 2.0705307456363065e-20]
-0.04993068808288777

[-0.04993068808288777, -0.04986123090790862, -0.04965218192181728, -0.04929952457719835, -0.0487962499071602, -0.048132173961807356, -0.047293517606996474, -0.04626225758342355, -0.045015135307373624, -0.043522110835122085, -0.04174385745843286, -0.03962746333768656, -0.037098427065343054, -0.03404387084344901, -0.03027160420042525, -0.02537001026224403, -0.0177183208238238, -0.010063537641023029, -0.0051524909602164055, -0.0013638954398079298, 0.001714736422091034, 0.0042768324589081835, 0.006436893394751322, 0.008271453851901065, 0.009835900210059574, 0.011172512946159223, 0.012314810493149623, 0.013290108673479135, 0.014121130509695583, 0.01482707270549229, 0.015424343231701661, 0.015927090695608506, 0.01634759686624379, 0.016696576304076914, 0.016983411071273973, 0.017216338837234165, 0.017402606664142076, 0.017548598894288052, 0.017659945031386518, 0.017741611820621967, 0.017797982587956, 0.01783292611192468, 0.017849856751791227, 0.017851787167150083, 0.01784137468483667, 0.01782096216513735, 0.017792614067766086, 0.01775814830318938, 0.017719164365903574, 0.017677068175809232, 0.01763309399677941, 0.01758832375433719, 0.017543704034562436, 0.01750006101219312, 0.017458113526128253, 0.017418484494267805, 0.017381710836190632, 0.017348252050993204, 0.01731849757856231, 0.017292773054280335, 0.01727134555343825, 0.0172544278975186, 0.017242182137899374, 0.017234722309833958, 0.01723212961682039]
In [41]:
print(x_values)
[0.0, 0.015625, 0.03125, 0.046875, 0.0625, 0.078125, 0.09375, 0.109375, 0.125, 0.140625, 0.15625, 0.171875, 0.1875, 0.203125, 0.21875, 0.234375, 0.25, 0.265625, 0.28125, 0.296875, 0.3125, 0.328125, 0.34375, 0.359375, 0.375, 0.390625, 0.40625, 0.421875, 0.4375, 0.453125, 0.46875, 0.484375, 0.5, 0.515625, 0.53125, 0.546875, 0.5625, 0.578125, 0.59375, 0.609375, 0.625, 0.640625, 0.65625, 0.671875, 0.6875, 0.703125, 0.71875, 0.734375, 0.75, 0.765625, 0.78125, 0.796875, 0.8125, 0.828125, 0.84375, 0.859375, 0.875, 0.890625, 0.90625, 0.921875, 0.9375, 0.953125, 0.96875, 0.984375, 1.0]
In [74]:
# This is for Example 3

x_values   = [0.0, 0.015625, 0.03125, 0.046875, 0.0625, 0.078125, 0.09375, 0.109375, 0.125, 0.140625, 0.15625, 0.171875, 0.1875, 0.203125, 0.21875, 0.234375, 0.25, 0.265625, 0.28125, 0.296875, 0.3125, 0.328125, 0.34375, 0.359375, 0.375, 0.390625, 0.40625, 0.421875, 0.4375, 0.453125, 0.46875, 0.484375, 0.5, 0.515625, 0.53125, 0.546875, 0.5625, 0.578125, 0.59375, 0.609375, 0.625, 0.640625, 0.65625, 0.671875, 0.6875, 0.703125, 0.71875, 0.734375, 0.75, 0.765625, 0.78125, 0.796875, 0.8125, 0.828125, 0.84375, 0.859375, 0.875, 0.890625, 0.90625, 0.921875, 0.9375, 0.953125, 0.96875, 0.984375, 1.0]

p_coupled  = [0.0, 3216.6015768694483, 6468.335452308252, 9791.881998774792, 13227.214084575897, 16819.780843331242, 20623.489757339747, 24705.080680739273, 29150.963554133024, 34078.61597631426, 39657.016825645354, 46146.73268900501, 53988.20005350825, 64026.43146968265, 78185.35792125853, 101846.28413974684, 153450.47129142884, 102783.2701488007, 80064.29051856881, 66857.28451196346, 57786.06738957997, 50931.99160296242, 45455.55247513162, 40922.11290569583, 37077.27255961682, 33758.672050603105, 30856.00743041904, 28290.716637516547, 26004.727294242093, 23953.798001404935, 22103.36847387006, 20425.86291812285, 18898.876105474115, 17503.91700935909, 16225.516430649159, 15050.579023888964, 13967.903475135001, 12967.82086770479, 12041.917705875743, 11182.82061754129, 10384.026691519162, 9639.768058781438, 8944.902508032566, 8294.824136989304, 7685.38960036554, 7112.85663067944, 6573.832315090352, 6065.229202200983, 5584.227749619571, 5128.243949266873, 4694.9012131746285, 4282.005789267027, 3887.525119662732, 3509.5686644446823, 3146.3707996763023, 2796.2754656114303, 2457.7222939246412, 2129.233984633543, 1809.4047366299626, 1496.8895622141747, 1190.3943371174237, 888.6664542480565, 590.4859625958932, 294.6570829729687, 1.570051298959911e-14]
p_StR      = [0.0, 3333.962733759207, 6702.740401333866, 10142.691907205199, 13693.455556526027, 17400.12566401273, 21316.226665139176, 25508.077908054966, 30061.620216276424, 35093.79934551655, 40772.9807772086, 47359.00944402064, 55291.45105335408, 65414.2289069175, 79649.82914447266, 103377.41535664373, 155034.28709826845, 104400.39624756394, 81700.72531981103, 68502.96113776883, 59433.03176164038, 52573.70395106216, 47086.52875457103, 42537.70249421777, 38673.50438272141, 35332.14057510409, 32403.784259106, 29810.27970747092, 27493.902821899108, 25410.71204202528, 23526.405975437272, 21813.632775320944, 20250.1811225291, 18817.727949629658, 17500.949516156026, 16286.876379232752, 15164.41610572358, 14123.993833421302, 13157.277205731847, 12256.962743406633, 11416.607643014951, 10630.495639138511, 9893.528743713794, 9201.138883265648, 8549.215011602222, 7934.042388402232, 7352.251519381017, 6800.774842928507, 6276.809683689338, 5777.786318649626, 5301.340246109273, 4845.287933836507, 4407.605465020731, 3986.409610407464, 3579.940940261974, 3186.5486564723274, 2804.6768775349997, 2432.852150615561, 2069.6719977745597, 1713.7943296221108, 1363.9275804933825, 1018.8214357639837, 677.2580349375866, 338.04354423125045, 1.7999335028691466e-14]
p_RtS      = [0.0, 3350.397115114588, 6735.599820770952, 10191.957972437523, 13759.100001873687, 17482.109141495912, 21414.497182630523, 25622.56895465187, 30192.248622051975, 35240.46292799452, 40935.555830129604, 47537.34812518236, 55485.37872760383, 65623.54149797035, 79874.29054546411, 103616.75494464241, 155288.1973928564, 104668.53074849794, 81982.69655407076, 68798.33894220444, 59741.34182407467, 52894.42663014008, 47419.09819682637, 42881.50606555178, 39027.882430465164, 35696.38653572645, 32777.145125126845, 30191.956865012256, 27883.0532674236, 25806.449983140734, 23927.80481625264, 22219.727481860304, 20659.97095833798, 19230.179566163933, 17915.000377058765, 16701.438492401794, 15578.38003235218, 14536.232939124064, 13566.65211557649, 12662.32596024684, 11816.808287005226, 11024.384265715047, 10279.962197615938, 9578.985147290923, 8917.35801064897, 8291.386711854813, 7697.727027916508, 7133.341129248118, 6595.460360376364, 6081.553110205727, 5589.296866105081, 5116.553731923132, 4661.34883218913, 4221.851134270112, 3796.356305196787, 3383.271286159246, 2981.10031969244, 2588.4322055841444, 2203.928593990397, 1826.3131499767478, 1454.3614441102711, 1086.8914398615382, 722.7544612362652, 360.8265338454283, 1.9200155203971836e-14]
p_exact    = [-0.0, 3151.2006975563977, 6377.098963299969, 9732.467983455885, 13243.465004721676, 16915.96061893681, 20758.49465060035, 24810.659687040486, 29165.859956617536, 33981.92797719413, 39482.99483429896, 45969.51161747231, 53872.803876127466, 63938.90461137616, 77836.0948147382, 100986.12410792217, 197641.60105484753, 101898.39004960032, 79682.32535711114, 66752.96384365455, 57687.06732209139, 50804.90374091848, 45348.56083330672, 40884.49941180301, 37124.68496734051, 33868.95444242153, 30985.433786279573, 28397.911950019232, 26069.44393263948, 23982.413594655143, 22120.521713574726, 20458.400860178754, 18961.192475416723, 17591.869443127787, 16320.887948858059, 15132.447914160028, 14024.154603542098, 13000.704038683743, 12065.315964295416, 11213.502112950595, 10432.141647159744, 9703.791977069164, 9013.401220817874, 8353.542109011469, 7725.3853998995155, 7135.1405266011225, 6588.177344957807, 6084.172297649809, 5615.867380300727, 5171.906355972764, 4741.946802585553, 4321.081294322934, 3911.1219539356107, 3518.1499855654633, 3147.835221808995, 2801.220542460599, 2473.3166364371555, 2155.2073575697978, 1838.376828615945, 1518.7527076007916, 1198.1756756259856, 882.5023029604296, 577.4651985834532, 284.66928050524103, -6.112219581427123e-11]

u1_coupled = [6.943870026570695e-20, -0.0013796393457558656, -0.0027530845626919, -0.004113740095135691, -0.0054551254630405355, -0.0067709045078118025, -0.008054919145270586, -0.00930122213258162, -0.010504101454410579, -0.011658086000222575, -0.01275790835150678, -0.013798360689583103, -0.014773854652627077, -0.015677128957815402, -0.016495347156215433, -0.017199094138998748, -0.018095755321299017, -0.018919055905628285, -0.019403275501805414, -0.019857453960091698, -0.02025490461627154, -0.020586551226460133, -0.02084986758006619, -0.021044905776602865, -0.021172924176730036, -0.021235859966081246, -0.021236092746671487, -0.02117631247797221, -0.021059430059390177, -0.02088850838784261, -0.020666705314215224, -0.02039722494092951, -0.020083275674441747, -0.019728034245414732, -0.019334615220249818, -0.018906045629502356, -0.018445244353218676, -0.017955005886436833, -0.017437988086080585, -0.01689670348484412, -0.016333513752684197, -0.015750626892761386, -0.01515009677481237, -0.01453382463293723, -0.013903562184384603, -0.013260916058983213, -0.012607353263547044, -0.011944207440370102, -0.011272685712673862, -0.010593875941751383, -0.009908754250024765, -0.009218192690989436, -0.008522966970933347, -0.007823764148407807, -0.007121190255798272, -0.006415777803178559, -0.005707993138139812, -0.0049982436466973965, -0.004286884789917803, -0.003574226978778852, -0.0028605422961966867, -0.0021460710806244752, -0.0014310283907427524, -0.0007156106424246277, 1.9874078175710532e-20]
u1_StR     = [7.219745850184808e-20, -0.0014431506315405326, -0.002879915146123133, -0.004303504501041136, -0.0057072464081008864, -0.007084615916446512, -0.008429270118492822, -0.00973508198120294, -0.010996165852766774, -0.012206884434041339, -0.013361813327156203, -0.014455599967139125, -0.015482530133072995, -0.016435252832534792, -0.017300927943428066, -0.01805036118058374, -0.018987027290969943, -0.019847782031472878, -0.020370045714231323, -0.02085897790823652, -0.02128816322744637, -0.02164859198981552, -0.021937737885721148, -0.02215563561688732, -0.022303525463325778, -0.022383331732690165, -0.022397428485564645, -0.022348508229378, -0.022239492672622766, -0.022073463673412317, -0.02185360593284882, -0.02158315793629284, -0.02126536958982573, -0.020903465785585496, -0.020500615434352, -0.020059905602145097, -0.019584320399967044, -0.01907672425749856, -0.01853984918832413, -0.017976285637567646, -0.01738847649687721, -0.016778713877034248, -0.01614913824378856, -0.01550173954578001, -0.01483835999234283, -0.01416069817147042, -0.013470314232392016, -0.012768635891575852, -0.012056965054366762, -0.011336484876062381, -0.010608267115480196, -0.00987327966065445, -0.009132394130092649, -0.008386393474026291, -0.007635979518411197, -0.00688178041024405, -0.006124357936266866, -0.005364214698555731, -0.004601801140051006, -0.003837522420982979, -0.0030717451535921827, -0.002304804008106114, -0.0015370082083374296, -0.0007686482616168684, 2.1347025945087728e-20]
u1_RtS     = [6.6456177680517e-20, -0.001339986836119607, -0.0026741868629182684, -0.003996461552466525, -0.005300775492698601, -0.006581224462346359, -0.007832066576715965, -0.00904775282356226, -0.010222950445722124, -0.01135255044035866, -0.01243163877027191, -0.01345537732620872, -0.014418635147534116, -0.015314901010240807, -0.016132995541724277, -0.016847795512479908, -0.017718320823822593, -0.018519622440838122, -0.019027252938323528, -0.01950172931243501, -0.01992039800680083, -0.020275484687200265, -0.020564768387784614, -0.020788232332037096, -0.02094690615215453, -0.02104241989716826, -0.021076803196679882, -0.021052372257238224, -0.02097165271912754, -0.02083731973022703, -0.020652148044240797, -0.020418969175426297, -0.020140634298549318, -0.019819982251111666, -0.019459812252189575, -0.01906286103362574, -0.01863178408756921, -0.018169140716715132, -0.017677382552078822, -0.017158845187521827, -0.016615742574111143, -0.016050163821163976, -0.01546407206337796, -0.014859305072983093, -0.014237577320413081, -0.013600483214730001, -0.012949501284332978, -0.012285999088024887, -0.011611238675289522, -0.010926382441914776, -0.010232499252398787, -0.009530570723613184, -0.008821497584845461, -0.008106106047601295, -0.0073851541344985, -0.006659337930372206, -0.0059292977305070915, -0.0051956240709061935, -0.004458863633880122, -0.003719525029161902, -0.00297808445640162, -0.0022349912598830205, -0.001490673391497661, -0.0007455431714860744, 2.0705307456363065e-20]
u1_exact   = [0.0, -0.0013879407417285506, -0.002769351256106114, -0.004137748193067679, -0.005486742061977878, -0.006810084385318271, -0.00810171501020685, -0.009355809437189304, -0.010566825853903701, -0.011729551356178832, -0.01283914662388812, -0.013891188124004666, -0.014881706769804914, -0.01580722189725644, -0.016664769443062975, -0.01745192339779841, -0.018166681085397873, -0.018808108298584612, -0.019375057716761207, -0.01986743523855166, -0.020285539794028876, -0.02063016342223302, -0.020902555820964595, -0.021104383080070614, -0.021237681808171125, -0.021304810065514598, -0.02130839654880246, -0.021251289417160913, -0.021136506021747548, -0.020967184627817905, -0.020746539021214948, -0.02047781669015683, -0.020164261079658623, -0.01980907823493212, -0.01941540798298588, -0.018986299649661066, -0.018524692176043585, -0.018033398388988448, -0.017515093100689026, -0.016972304664109136, -0.016407409592119327, -0.015822629851440596, -0.015220032459052311, -0.014601531030446178, -0.013968888951677173, -0.013323723869967012, -0.012667513223000032, -0.01200160055724596, -0.011327202421075688, -0.010645415656459871, -0.009957224949301367, -0.009263510528671377, -0.008565055927453335, -0.007862555732218038, -0.007156623261975501, -0.006447798127549038, -0.005736553637851771, -0.005023304035783717, -0.004308411562093098, -0.0035921933571454526, -0.002874928216273789, -0.0021568632149109378, -0.001438220217877197, -0.000719202286503671, -1.7949591641954953e-18]

u2_coupled = [-0.05405579690460371, -0.05398273606126123, -0.05376259800904707, -0.05339056405507719, -0.052858247905189, -0.052153462570662036, -0.051259714944827374, -0.05015542704243629, -0.04881274873128561, -0.04719570934034339, -0.045257227659644364, -0.04293399061802553, -0.040136930059288166, -0.03673127470987305, -0.032487948969960205, -0.026917345981186693, -0.01809575532130064, -0.009276073872163325, -0.0037109991235477913, 0.0005237806374419362, 0.003918884851711303, 0.006704828818490286, 0.009018273145732756, 0.010950654552259662, 0.012568171089231507, 0.013921350836535664, 0.015050227874163803, 0.01598739727634817, 0.01675994032685144, 0.017390702586518918, 0.01789917967479105, 0.018302154287188052, 0.018614169398492638, 0.018847890011140782, 0.01901438681963499, 0.019123363670294165, 0.019183343519382105, 0.019201822992010474, 0.01918540262887361, 0.019139897893868718, 0.019070434647954063, 0.018981531851632334, 0.01887717359881052, 0.018760872116529617, 0.01863572302746014, 0.018504453924520648, 0.018369467122079545, 0.01823287730728189, 0.018096544705324263, 0.01796210428517897, 0.017830991461259386, 0.017704464687582796, 0.017583625291164997, 0.01746943484857499, 0.01736273037229281, 0.017264237540651813, 0.017174582175919134, 0.017094300148767883, 0.017023845863854584, 0.016963599458816765, 0.016913872832136228, 0.016874914586228956, 0.01684691401304481, 0.016830004155918104, 0.01682427338816445]
u2_StR     = [-0.055408883955444396, -0.05533292338828128, -0.055104159592575704, -0.05471786139510934, -0.05416578549283027, -0.053435952789881, -0.05251215197518023, -0.051373173957157146, -0.049991643887594216, -0.048332201511706495, -0.04634855564216936, -0.04397843583092352, -0.04113419967279355, -0.037683149034154505, -0.03339955578851475, -0.027800532049443636, -0.018987027290971292, -0.010173315383818177, -0.004573470923626187, -0.00028784250354408497, 0.0031674694652213536, 0.006019631156936781, 0.008403227184578905, 0.010408263883757938, 0.012099889543143677, 0.013527831668319733, 0.014731498855463017, 0.015742989979691882, 0.016588989072625744, 0.017292022190565793, 0.017871327739413745, 0.018343481830714325, 0.018722862440287046, 0.019022003983448492, 0.019251875187349613, 0.01942210180608864, 0.019541148647476837, 0.019616470844810985, 0.019654641335481025, 0.019661459524459846, 0.019642044764381965, 0.01960091735640145, 0.019542069127809494, 0.01946902518277936, 0.01938489809168304, 0.01929243554214696, 0.01919406229433798, 0.019091917145497496, 0.018987885501870926, 0.01888362807124324, 0.018780606120294304, 0.018680103683767012, 0.018583247064081754, 0.018491021918480406, 0.018404288194574063, 0.018323793143230755, 0.01825018260930063, 0.018184010775049563, 0.01812574850819959, 0.018075790444557708, 0.018034460918748895, 0.018002018827914135, 0.01797866155749813, 0.017964528026919717, 0.017959712270519852]
u2_RtS     = [-0.04993068808288777, -0.04986123090790862, -0.04965218192181728, -0.04929952457719835, -0.0487962499071602, -0.048132173961807356, -0.047293517606996474, -0.04626225758342355, -0.045015135307373624, -0.043522110835122085, -0.04174385745843286, -0.03962746333768656, -0.037098427065343054, -0.03404387084344901, -0.03027160420042525, -0.02537001026224403, -0.0177183208238238, -0.010063537641023029, -0.0051524909602164055, -0.0013638954398079298, 0.001714736422091034, 0.0042768324589081835, 0.006436893394751322, 0.008271453851901065, 0.009835900210059574, 0.011172512946159223, 0.012314810493149623, 0.013290108673479135, 0.014121130509695583, 0.01482707270549229, 0.015424343231701661, 0.015927090695608506, 0.01634759686624379, 0.016696576304076914, 0.016983411071273973, 0.017216338837234165, 0.017402606664142076, 0.017548598894288052, 0.017659945031386518, 0.017741611820621967, 0.017797982587956, 0.01783292611192468, 0.017849856751791227, 0.017851787167150083, 0.01784137468483667, 0.01782096216513735, 0.017792614067766086, 0.01775814830318938, 0.017719164365903574, 0.017677068175809232, 0.01763309399677941, 0.01758832375433719, 0.017543704034562436, 0.01750006101219312, 0.017458113526128253, 0.017418484494267805, 0.017381710836190632, 0.017348252050993204, 0.01731849757856231, 0.017292773054280335, 0.01727134555343825, 0.0172544278975186, 0.017242182137899374, 0.017234722309833958, 0.01723212961682039]
u2_exact   = [-0.054197172978721966, -0.05412444506683698, -0.053904543081984516, -0.053532308847181964, -0.05299910024510892, -0.05229261684675777, -0.05139647647618091, -0.050289419422169336, -0.04894401028714081, -0.04732464753679696, -0.0453844941667277, -0.04306044714107546, -0.040264040877462146, -0.03686278098905749, -0.032634522229007215, -0.027116286501651987, -0.018166681085397852, -0.009218942279125038, -0.003706062958915072, 0.0005140581893757124, 0.0039055219263906295, 0.00669196383877764, 0.00900773012190968, 0.010943550819316942, 0.01256530389262296, 0.01392322326489186, 0.015057017920696357, 0.015998987333524225, 0.016776025569943016, 0.017410936557532498, 0.017923294476444522, 0.01833000886487045, 0.018645717955256335, 0.01888310139144836, 0.019053165191288815, 0.019165513214827207, 0.01922859166032319, 0.019249884252068555, 0.01923604547720762, 0.019192978869288665, 0.01912588463343697, 0.019039306204245047, 0.01893719622459308, 0.01882300441816908, 0.018699772799385894, 0.018570216404600475, 0.018436773317017097, 0.01830162226810308, 0.018166681085397842, 0.01803360651267484, 0.01790381187090529, 0.017778506395081398, 0.017658746151684866, 0.01754547888412844, 0.017439567820224582, 0.01734179051323488, 0.01725282176108166, 0.017173217287988367, 0.017103413078275766, 0.01704374526116611, 0.016994483014842535, 0.016955859074822242, 0.016928083414252008, 0.016911334810517965, 0.01690573706820936]

# The first is p

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, p_coupled, 'o', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, p_StR    , 's', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, p_RtS    , '^', label='RtS algorithm',     markerfacecolor='none')
plt.plot(x_values, p_exact  , '-', label='reference')

ax.set_xlabel('y',labelpad=10,size=14,)
ax.set_ylabel('pressure $p$',labelpad=10,size=14,)
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(10, 6)
plt.legend(loc=0, prop = {'size':14})
plt.savefig("./BMP.eps",dpi=600)
plt.show()


import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, u1_coupled, 'o', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, u1_StR    , 's', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, u1_RtS    , '^', label='RtS algorithm',     markerfacecolor='none')
plt.plot(x_values, u1_exact  , '-', label='reference')

ax.set_xlabel('y',labelpad=10,size=14,)
ax.set_ylabel('$x$-displacement $u_1$',labelpad=10,size=14,)
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(10, 6)
plt.legend(loc=4, prop = {'size':14})
plt.savefig("./BMU1.eps",dpi=600)
plt.show()

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, u2_coupled, 'o', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, u2_StR    , 's', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, u2_RtS    , '^', label='RtS algorithm',     markerfacecolor='none')
plt.plot(x_values, u2_exact  , '-', label='reference')

ax.set_xlabel('y',labelpad=10,size=14,)
ax.set_ylabel('$y$-displacement $u_2$',labelpad=10,size=14,)
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(10, 6)
plt.legend(loc=4, prop = {'size':14})
plt.savefig("./BMU2.eps",dpi=600)
plt.show()
The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

In [72]:
# This is for Example 3

x_values   = [0.0, 0.015625, 0.03125, 0.046875, 0.0625, 0.078125, 0.09375, 0.109375, 0.125, 0.140625, 0.15625, 0.171875, 0.1875, 0.203125, 0.21875, 0.234375, 0.25, 0.265625, 0.28125, 0.296875, 0.3125, 0.328125, 0.34375, 0.359375, 0.375, 0.390625, 0.40625, 0.421875, 0.4375, 0.453125, 0.46875, 0.484375, 0.5, 0.515625, 0.53125, 0.546875, 0.5625, 0.578125, 0.59375, 0.609375, 0.625, 0.640625, 0.65625, 0.671875, 0.6875, 0.703125, 0.71875, 0.734375, 0.75, 0.765625, 0.78125, 0.796875, 0.8125, 0.828125, 0.84375, 0.859375, 0.875, 0.890625, 0.90625, 0.921875, 0.9375, 0.953125, 0.96875, 0.984375, 1.0]

p_coupled  = [0.0, 3222.651379108747, 6480.418638185734, 9809.96547168878, 13251.24732102609, 16849.694734453486, 20659.19499436034, 24746.465612240754, 29197.891405252532, 34130.92126057629, 39714.50068047977, 46209.15668599987, 54055.27767570512, 64097.815624960764, 78260.6205724449, 101924.87634457086, 153531.61964965638, 102865.89701507363, 80147.62300153043, 66940.77464210395, 57869.288475676, 51014.598134214175, 45537.259564165644, 41002.68356261129, 37156.50887393997, 33836.40864552774, 30932.10637598506, 28365.063367018043, 26077.22724690449, 24024.37381257085, 22171.95759164043, 20492.415561105136, 18963.353499323453, 17566.28985519474, 16285.763569045921, 15108.686265674838, 14023.862575713154, 13021.628625715413, 12093.575170148135, 11232.332388738481, 10431.400306836667, 9685.013449657132, 8988.031522146537, 8335.850116943386, 7724.327012378226, 7149.720737445317, 6608.638887658643, 6097.99426634357, 5614.967362699233, 5156.974004092344, 4721.637265749669, 4306.762907713105, 3910.3177519253936, 3530.4105226875663, 3165.2747595283163, 2813.253478666059, 2472.785312099046, 2142.391895182244, 1820.6663067762186, 1506.262392514393, 1197.8848228122351, 894.2797539803727, 594.2259739933062, 296.52642470124624, 1.5799702028661948e-14]
p_StR      = [0.0, 3233.540530846932, 6502.1672845941275, 9842.513841028396, 13294.504194093499, 16903.535382930808, 20723.45830752511, 24820.95028370282, 29282.35098410139, 34225.057765408405, 39817.9562970389, 46321.50274807797, 54175.99949060569, 64226.290252606, 78396.08067893863, 102066.33947418084, 153677.7034294006, 103014.67317990179, 80297.7098480217, 67091.19097325888, 58019.268643467796, 51163.521065358946, 45684.61227944646, 41148.038528487, 37299.50830054516, 33976.75283184311, 31069.544653425946, 28499.386829073777, 26208.262771319638, 24151.979057718458, 22296.016751607647, 20612.835727625094, 19080.06151970842, 17679.229602834323, 16394.89356192757, 15213.977581783523, 14125.297023923697, 13119.197138076257, 12187.276387026008, 11322.171412650448, 10517.387604276271, 9767.163883054991, 9066.363496452694, 8410.384827291931, 7795.087780974096, 7216.732429257778, 6671.927395758836, 6157.586058817399, 5670.889084026589, 5209.252124729622, 4770.297774399799, 4351.831041429634, 3951.8177597849467, 3568.3654592877506, 3199.7063050339602, 2844.1817825422445, 2500.228858041359, 2166.3673850882124, 1841.1885619022964, 1523.344270234499, 1211.5371476409682, 904.5112617505089, 601.0432682865456, 299.9339448267745, 1.598049073625141e-14]
p_RtS      = [0.0, 3233.5475560701043, 6502.181321398968, 9842.534862389362, 13294.532159594753, 16903.570238757584, 20723.49998645382, 24820.99870509148, 29282.406053882234, 34225.11937608477, 39818.02432768897, 46321.577064367826, 54176.0799448149, 64226.376683668495, 78396.1729125021, 102066.4373226884, 153677.80669219713, 103014.78164336883, 80297.8232857444, 67091.30914622718, 58019.39130031579, 51163.64794264465, 45684.743101974644, 41148.17300967737, 37299.64614284792, 33976.893727203416, 31069.688283798565, 28499.53286698874, 26208.41088049946, 24152.128893746725, 22296.16796264872, 20612.987955194007, 19080.21439948957, 17679.382765547245, 16395.046634237566, 15214.130187254481, 14125.448784010041, 13119.347673150705, 12187.4253174391, 11322.318359817882, 10517.532191789503, 9767.305737810371, 9066.502249794166, 8410.520116162064, 7795.219249068112, 7216.859728175103, 6672.050186146542, 6157.704011499938, 5671.00188111617, 5209.3594607116, 4770.39935718756, 4351.926593383516, 3951.907018689895, 3568.44817928463, 3199.7822574995744, 2844.2507569134436, 2500.2906625788332, 2166.4218475759035, 1841.2355302786816, 1523.383613152335, 1211.568754952496, 904.5350449154778, 601.0591607008524, 299.94190206991595, 1.5980909267801363e-14]
p_exact    = [-0.0, 3151.2006975563977, 6377.098963299969, 9732.467983455885, 13243.465004721676, 16915.96061893681, 20758.49465060035, 24810.659687040486, 29165.859956617536, 33981.92797719413, 39482.99483429896, 45969.51161747231, 53872.803876127466, 63938.90461137616, 77836.0948147382, 100986.12410792217, 197641.60105484753, 101898.39004960032, 79682.32535711114, 66752.96384365455, 57687.06732209139, 50804.90374091848, 45348.56083330672, 40884.49941180301, 37124.68496734051, 33868.95444242153, 30985.433786279573, 28397.911950019232, 26069.44393263948, 23982.413594655143, 22120.521713574726, 20458.400860178754, 18961.192475416723, 17591.869443127787, 16320.887948858059, 15132.447914160028, 14024.154603542098, 13000.704038683743, 12065.315964295416, 11213.502112950595, 10432.141647159744, 9703.791977069164, 9013.401220817874, 8353.542109011469, 7725.3853998995155, 7135.1405266011225, 6588.177344957807, 6084.172297649809, 5615.867380300727, 5171.906355972764, 4741.946802585553, 4321.081294322934, 3911.1219539356107, 3518.1499855654633, 3147.835221808995, 2801.220542460599, 2473.3166364371555, 2155.2073575697978, 1838.376828615945, 1518.7527076007916, 1198.1756756259856, 882.5023029604296, 577.4651985834532, 284.66928050524103, -6.112219581427123e-11]

u1_coupled = [6.964198426540552e-20, -0.001384136378061908, -0.00276206290727723, -0.004127167886703157, -0.005472954889862577, -0.006793072112730004, -0.008081346213435266, -0.00933181517142319, -0.010538752762804278, -0.01169667432318881, -0.012800299616534843, -0.013844408821181268, -0.01482340246438669, -0.015730009130495402, -0.01655138333770494, -0.0172581022478927, -0.01815754447597428, -0.018983426835702307, -0.01947002159783273, -0.019926364950700857, -0.02032576769554122, -0.020659151754040168, -0.020923989912721777, -0.021120334131574, -0.021249443475040167, -0.02131325663335999, -0.02131415546047764, -0.021254832855522963, -0.02113820328231029, -0.020967333762389417, -0.020745386766851063, -0.02047557145025215, -0.020161101641412587, -0.01980515980456708, -0.01941086649513881, -0.01898125493608513, -0.018519250355147163, -0.01802765370642076, -0.01750912937755115, -0.016966196468136317, -0.01640122321987411, -0.015816424185157132, -0.015213859736919607, -0.014595437546511013, -0.01396291568595186, -0.013317907043981054, -0.012661884779978805, -0.011996188574639808, -0.011322031470023532, -0.010640507123499046, -0.009952597329585573, -0.009259179690459075, -0.008561035339823922, -0.007858856645950957, -0.007153254838069125, -0.006444767516146145, -0.005733866017615182, -0.005020962626028051, -0.004306417616166339, -0.0035905461380224546, -0.0028736249484922027, -0.002155899005102684, -0.0014375879412337317, -0.0007188927167811214, 1.9965227509433958e-20]
u1_StR     = [6.995481886491155e-20, -0.0013910796578949507, -0.0027759254465718696, -0.004147901028906436, -0.005500485639717863, -0.00682730359095603, -0.008122158243330336, -0.009379065006204376, -0.010592275949950975, -0.0117562857023681, -0.012865794450279662, -0.01391556406620757, -0.0148999782189303, -0.015811750375512065, -0.016638022346632045, -0.017349362662957443, -0.01825310121955951, -0.01908297446073987, -0.019573275868489656, -0.02003299763753821, -0.020435449762589472, -0.020771552303550284, -0.02103877669045642, -0.02123717456821412, -0.02136800586518791, -0.02143321131340581, -0.021435175932183394, -0.021376596832855674, -0.021260393650920868, -0.021089639446757184, -0.020867503503388354, -0.020597202466888676, -0.020281958245826053, -0.019924961884489275, -0.019529342935129174, -0.019098143955882062, -0.018634299775211662, -0.018140621146609585, -0.01761978239502189, -0.01707431264062076, -0.01650659018038174, -0.015918839614009164, -0.015313131316785444, -0.01469138288584111, -0.014055362215888368, -0.013406691893493338, -0.012746854633626556, -0.012077199517018848, -0.011398948820607815, -0.010713205265259528, -0.010020959534448523, -0.009323097944364372, -0.008620410169860213, -0.007913596951779971, -0.007203277729606507, -0.006489998159240248, -0.005774237489258448, -0.005056415780446477, -0.0043369009629595865, -0.0036160157333696664, -0.0028940443002934803, -0.0021712389927980693, -0.0014478267509438953, -0.0007240157968017539, 2.01075049544508e-20]
u1_RtS     = [6.969537326711579e-20, -0.0013870257688405052, -0.0027678423136431826, -0.004135840804031611, -0.005484527439784791, -0.006807552961778987, -0.008098746596815738, -0.009352149073731305, -0.010562037374714584, -0.011722931053490315, -0.012829556321883975, -0.013876704936479752, -0.014858801738332327, -0.015768633561955965, -0.016593509961286584, -0.017304435713172635, -0.018203932872758365, -0.019029838164103786, -0.019520542481822417, -0.01998022164152563, -0.02038260785637647, -0.020718769709003788, -0.02098622797708852, -0.021185047131604795, -0.021316484843322877, -0.021382472498729366, -0.021385382023525138, -0.021327895344666104, -0.021212915790536614, -0.021043499634916182, -0.020822799359970928, -0.020554015148883, -0.02024035305631528, -0.019884989088820294, -0.01949103873127618, -0.01906153155386751, -0.018599390546872374, -0.018107415812689553, -0.01758827222181349, -0.017044480623241084, -0.01647841219426274, -0.015892285520268296, -0.015288166010800379, -0.014667967281559979, -0.014033454161163158, -0.013386247014042018, -0.012727827105131493, -0.012059542766390947, -0.011382616158622991, -0.010698150453650482, -0.010007137291149774, -0.009310464391003685, -0.008608923225801356, -0.007903216679084212, -0.007193966633223734, -0.006481721446590564, -0.005766963293143617, -0.00505011534895614, -0.004331548819724479, -0.0036115898111744285, -0.002890526050704974, -0.0021686134740988763, -0.0014460826962952415, -0.0007231456655771471, 2.0083338202873054e-20]
u1_exact   = [0.0, -0.0013879407417285506, -0.002769351256106114, -0.004137748193067679, -0.005486742061977878, -0.006810084385318271, -0.00810171501020685, -0.009355809437189304, -0.010566825853903701, -0.011729551356178832, -0.01283914662388812, -0.013891188124004666, -0.014881706769804914, -0.01580722189725644, -0.016664769443062975, -0.01745192339779841, -0.018166681085397873, -0.018808108298584612, -0.019375057716761207, -0.01986743523855166, -0.020285539794028876, -0.02063016342223302, -0.020902555820964595, -0.021104383080070614, -0.021237681808171125, -0.021304810065514598, -0.02130839654880246, -0.021251289417160913, -0.021136506021747548, -0.020967184627817905, -0.020746539021214948, -0.02047781669015683, -0.020164261079658623, -0.01980907823493212, -0.01941540798298588, -0.018986299649661066, -0.018524692176043585, -0.018033398388988448, -0.017515093100689026, -0.016972304664109136, -0.016407409592119327, -0.015822629851440596, -0.015220032459052311, -0.014601531030446178, -0.013968888951677173, -0.013323723869967012, -0.012667513223000032, -0.01200160055724596, -0.011327202421075688, -0.010645415656459871, -0.009957224949301367, -0.009263510528671377, -0.008565055927453335, -0.007862555732218038, -0.007156623261975501, -0.006447798127549038, -0.005736553637851771, -0.005023304035783717, -0.004308411562093098, -0.0035921933571454526, -0.002874928216273789, -0.0021568632149109378, -0.001438220217877197, -0.000719202286503671, -1.7949591641954953e-18]

u2_coupled = [-0.05417275927508995, -0.054099466811369804, -0.053878637353881806, -0.05350545383558083, -0.05297153226702866, -0.05226468904093339, -0.05136843569792461, -0.050261200412668496, -0.04891514104534913, -0.04729429715922376, -0.04535160054453362, -0.04302375457589109, -0.040221711895787784, -0.036810727656683466, -0.032561760263181735, -0.026985247901965055, -0.018157544475974067, -0.009331641607406264, -0.003760331284682261, 0.0004806346033037988, 0.0038818316524854594, 0.006673742825825314, 0.008993004429084796, 0.010931034945257385, 0.012554018960246131, 0.013912474925111083, 0.015046430414774515, 0.015988476557909474, 0.016765692794187017, 0.017400924563611846, 0.01791366877210812, 0.018320710543090302, 0.01863659619575654, 0.018873994802775566, 0.019043981692805526, 0.019156265772815637, 0.01921937536966878, 0.019240812690352098, 0.019227183985359417, 0.019184310486089068, 0.019117323819724794, 0.019030748662358148, 0.01892857473169308, 0.01881431975260644, 0.018691084691404805, 0.018561602307224104, 0.018428279884246584, 0.01829323686760226, 0.018158338016198667, 0.018025222598485605, 0.017895330086223512, 0.017769922742453616, 0.017650105450099263, 0.01753684308486961, 0.017430975698891932, 0.017333231748671744, 0.017244239571781766, 0.017164537290405815, 0.017094581296344367, 0.01703475344970705, 0.016985367106665497, 0.01694667206255996, 0.016918858537789922, 0.01690206024131026, 0.01689636605394175]
u2_StR     = [-0.05435063825063131, -0.05427699049809008, -0.054055100761624335, -0.053680155147863576, -0.05314377435973819, -0.05243378165514506, -0.05153369796989473, -0.050421963884307426, -0.049070753319416786, -0.04744412642029713, -0.04549504126501816, -0.0431602349124011, -0.04035070367364824, -0.036931760800519506, -0.03267444626044804, -0.027089329149219573, -0.018253101219560863, -0.009418500835244965, -0.0038380663798325836, 0.00041211344430782683, 0.003822485041119224, 0.006623452193216666, 0.0089515961326592, 0.010898295312698892, 0.012529704849254593, 0.013896321647430189, 0.015038157911371215, 0.015987794318080624, 0.016772303823314585, 0.01741452860366969, 0.017933964920284675, 0.018347399377079823, 0.018669381489806753, 0.018912584901481656, 0.01908809059715988, 0.019205613983568348, 0.019273690525664227, 0.01929983003358099, 0.019290646679615293, 0.01925196981208672, 0.019188939266146007, 0.01910608792941212, 0.01900741366132448, 0.01889644219738084, 0.01877628233229724, 0.018649674428986258, 0.01851903311569743, 0.018386484893044387, 0.018253901263183027, 0.01812292790630935, 0.01799501035882994, 0.017871416588792363, 0.017753256814486456, 0.017641500869446984, 0.017536993379911478, 0.017440466988018207, 0.017352553824880167, 0.01727379541143898, 0.017204651141518347, 0.017145505479144764, 0.01709667398538094, 0.017058408260848732, 0.017030899931589537, 0.01701428371481887, 0.017008649268254034]
u2_RtS     = [-0.05405966591991246, -0.053985923733800276, -0.053763772301869336, -0.05338846267014659, -0.05285172818328535, -0.05214155862763521, -0.051241705364978504, -0.050130918343383554, -0.048781782194376545, -0.0471589030931223, -0.04521597393653736, -0.04289074445816379, -0.040095662709754794, -0.036698262139864844, -0.032473357715359266, -0.02693949058804896, -0.018203932872759683, -0.0094697579680074, -0.003939839397616231, 0.0002791534187912338, 0.00366969410726679, 0.006458410162917279, 0.008779660478051171, 0.010723368379849706, 0.012354671181351225, 0.013723323467987747, 0.014868780757743769, 0.015823198241611883, 0.01661331943021026, 0.017261729244513302, 0.017787722063429483, 0.0182079257518178, 0.018536765105674397, 0.01878681611685053, 0.018969083799879265, 0.01909322503459264, 0.019167730831079952, 0.019200077907680593, 0.019196856514505117, 0.019163879460385617, 0.019106275961224512, 0.01902857300470031, 0.018934766281261332, 0.018828382273964026, 0.01871253277036148, 0.018589962818455964, 0.018463092968791554, 0.01833405650777274, 0.018204732280725538, 0.01807677361845204, 0.017951633812110002, 0.01783058852404192, 0.01771475547379141, 0.017605111696938625, 0.0175025086381101, 0.017407685307506502, 0.017321279701782197, 0.017243838664421637, 0.017175826337732233, 0.01711763133662099, 0.017069572757819878, 0.01703190510951537, 0.017004822287891533, 0.016988460637790286, 0.016982910853304018]
u2_exact   = [-0.054197172978721966, -0.05412444506683698, -0.053904543081984516, -0.053532308847181964, -0.05299910024510892, -0.05229261684675777, -0.05139647647618091, -0.050289419422169336, -0.04894401028714081, -0.04732464753679696, -0.0453844941667277, -0.04306044714107546, -0.040264040877462146, -0.03686278098905749, -0.032634522229007215, -0.027116286501651987, -0.018166681085397852, -0.009218942279125038, -0.003706062958915072, 0.0005140581893757124, 0.0039055219263906295, 0.00669196383877764, 0.00900773012190968, 0.010943550819316942, 0.01256530389262296, 0.01392322326489186, 0.015057017920696357, 0.015998987333524225, 0.016776025569943016, 0.017410936557532498, 0.017923294476444522, 0.01833000886487045, 0.018645717955256335, 0.01888310139144836, 0.019053165191288815, 0.019165513214827207, 0.01922859166032319, 0.019249884252068555, 0.01923604547720762, 0.019192978869288665, 0.01912588463343697, 0.019039306204245047, 0.01893719622459308, 0.01882300441816908, 0.018699772799385894, 0.018570216404600475, 0.018436773317017097, 0.01830162226810308, 0.018166681085397842, 0.01803360651267484, 0.01790381187090529, 0.017778506395081398, 0.017658746151684866, 0.01754547888412844, 0.017439567820224582, 0.01734179051323488, 0.01725282176108166, 0.017173217287988367, 0.017103413078275766, 0.01704374526116611, 0.016994483014842535, 0.016955859074822242, 0.016928083414252008, 0.016911334810517965, 0.01690573706820936]

# The first is p

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, p_coupled, 'o', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, p_StR    , 's', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, p_RtS    , '^', label='RtS algorithm',     markerfacecolor='none')
plt.plot(x_values, p_exact  , '-', label='reference')

ax.set_xlabel('y',labelpad=10,size=14,)
ax.set_ylabel('pressure $p$',labelpad=10,size=14,)
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(10, 6)
plt.legend(loc=0, prop = {'size':14})
plt.savefig("./BMP2.eps",dpi=600)
plt.show()


import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, u1_coupled, 'o', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, u1_StR    , 's', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, u1_RtS    , '^', label='RtS algorithm',     markerfacecolor='none')
plt.plot(x_values, u1_exact  , '-', label='reference')

ax.set_xlabel('y',labelpad=10,size=14,)
ax.set_ylabel('$x$-displacement $u_1$',labelpad=10,size=14,)
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(10, 6)
plt.legend(loc=4, prop = {'size':14})
plt.savefig("./BMU12.eps",dpi=600)
plt.show()

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, u2_coupled, 'o', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, u2_StR    , 's', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, u2_RtS    , '^', label='RtS algorithm',     markerfacecolor='none')
plt.plot(x_values, u2_exact  , '-', label='reference')

ax.set_xlabel('y',labelpad=10,size=14,)
ax.set_ylabel('$y$-displacement $u_2$',labelpad=10,size=14,)
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(10, 6)
plt.legend(loc=4, prop = {'size':14})
plt.savefig("./BMU22.eps",dpi=600)
plt.show()
The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

In [65]:
"""This demo program solves the three-field Biot's equation (Coupled)

Example 3.  Barry-Mercer's Problem

data 2023 07 05
"""

from dolfin import *
import time
import numpy as np
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha   = 1.0
c0      = 0.0
KK      = 1e-6
E       = 1e5
nu      = 0.1
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)
beta    = (lmbda + 2*mu)*KK

T       = np.pi/2*1e-9
stepnum = 1
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 1)
W = FiniteElement("CG", mesh.ufl_cell(), 1)
M = FiniteElement("CG", mesh.ufl_cell(), 1)

# Define boundary conditions
u_true    = Expression(("0.0","0.0"), degree=3, t=0.0)
u1_true   = Expression("0.0", degree=3, t=0.0)
u2_true   = Expression("0.0", degree=3, t=0.0)
p_true    = Expression("0.0", degree=2, t=0.0)
ksi_true  = Expression("0.0", degree=2, t=0.0)

f         = Expression(("0.0","0.0"), degree=2, t=0.0)
g         = Expression("0.0", degree=2, t=0.0)

w1_0      = Expression(("0.0","0.0","0.0"), degree=2, t=0.0)
p_0       = Expression("0.0", degree=2, t=0.0)
w_0       = Expression(("0.0","0.0","0.0","0.0"), degree=2, t=0.0)

def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

def boundary_u2(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

def boundary_u1(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

def boundary_p(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

# Here we try to use the Coupled algorithm to solve the Barry-Mercer's Problem
Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)

bc1c1 = DirichletBC(Qc.sub(0).sub(0), 0.0, boundary_u1)
bc1c2 = DirichletBC(Qc.sub(0).sub(1), 0.0, boundary_u2)
bc2c = DirichletBC(Qc.sub(2), 0.0, boundary_p)
bcc  = [bc1c1, bc1c2, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2.0*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1.0/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + alpha*alpha/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution

t = 0.0
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    A_ass, b_ass = assemble_system(lhs(Fc), rhs(Fc), bcc)

    ps = PointSource(Qc.sub(2), Point(0.25,0.25), 2.0*beta*np.sin(beta*t))
    ps.apply(b_ass)

    solve(A_ass, wc.vector(), b_ass)
    
    w_oldc.assign(wc)
    
(uc, ksic, pc) = wc.split(True)
# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(pc)

pic = plot(uc)
pyplot.colorbar(pic)
t = 1.5707963267948966e-09
Out[65]:
<matplotlib.colorbar.Colorbar at 0x7fdfb5449d90>

In [66]:
print(np.max(pc.vector().get_local()))

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values1.append(pc(Point(0.036,yy)))
    y_values2.append(pc(Point(0.107,yy)))
    y_values3.append(pc(Point(0.179,yy)))
    y_values4.append(pc(Point(0.250,yy)))

fig, ax = plt.subplots()
plt.plot(x_values, y_values1, 'o-', label='$x=0.036$', markerfacecolor='none')
plt.plot(x_values, y_values2, 's-', label='$x=0.107$', markerfacecolor='none')
plt.plot(x_values, y_values3, '^-', label='$x=0.179$', markerfacecolor='none')
plt.plot(x_values, y_values4, '+-', label='$x=0.250$', markerfacecolor='none')

ax.set_xlabel('y',labelpad=-10,size=14,)
ax.set_ylabel('pressure $p$',labelpad=1,size=14,)
ax.set_title('The First Time Step')
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(8, 4)
plt.xlim((0.0,1.0))
plt.legend(loc=0, prop = {'size':11})
plt.savefig("./BM111.eps",dpi=600)
plt.show()
print(y_values4)
7.031253310187088e-10
The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

[0.0, 5.91517514087471e-12, 2.3225191155188934e-12, -3.009819841723554e-11, 6.638393355143226e-11, -3.9850064157274217e-11, -2.8093512566328255e-13, 5.068416912319243e-11, 2.5379126405456714e-11, -1.093621336118853e-10, 2.1849282055589082e-10, -1.185126317771753e-10, 2.7435499815471597e-11, 1.128371378707594e-10, 1.0674559790787998e-10, -3.13885552509734e-10, 7.031253310187088e-10, -3.1764274820686666e-10, 1.094128194729047e-10, 1.1548600749714957e-10, 3.2208034428748075e-11, -1.3653850774542053e-10, 2.5407792376533706e-10, -1.3577867324874861e-10, 3.531117041679881e-11, 6.314746619538983e-11, 6.8486933807407315e-12, -7.535515152328504e-11, 1.3796468034162605e-10, -7.820911069297001e-11, 1.4143416081431713e-11, 4.051498287607907e-11, -2.476442635620019e-12, -4.400913551781161e-11, 8.100851338493164e-11, -4.782072190872166e-11, 5.351759741495648e-12, 2.7325784120123666e-11, -5.6698368148986765e-12, -2.5838398504187467e-11, 4.8492444229628706e-11, -2.949326190287044e-11, 1.3790192309842416e-12, 1.84497907664143e-11, -6.021643685768512e-12, -1.4864809491676277e-11, 2.8555492384297923e-11, -1.7769281227804994e-11, -2.175094182109585e-13, 1.1795763428448057e-11, -4.88626616972885e-12, -8.088167243031242e-12, 1.5683047926837994e-11, -9.888338768520275e-12, -5.376459137085624e-13, 6.403089704484181e-12, -2.9791310912542528e-12, -3.734797052893513e-12, 6.795608854145863e-12, -4.1750756640042214e-12, -2.605551176676886e-13, 1.7901454940411256e-12, -7.181834586170343e-13, -7.593341415335373e-13, 5.159519408460157e-30]
In [70]:
"""This demo program solves the three-field Biot's equation (Coupled)

Example 3.  Barry-Mercer's Problem For yi2017study

data 2023 07 02
"""

from dolfin import *
import time
import numpy as np
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model
dim     = 2
alpha   = 1.0
c0      = 0.0
KK      = 1e-6
E       = 1e5
nu      = 0.1
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)
beta    = (lmbda + 2*mu)*KK

T       = np.pi*1e-9
stepnum = 2
dt      = T/stepnum

# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

# Define boundary conditions
u_true    = Expression(("0.0","0.0"), degree=3, t=0.0)
u1_true   = Expression("0.0", degree=3, t=0.0)
u2_true   = Expression("0.0", degree=3, t=0.0)
p_true    = Expression("0.0", degree=2, t=0.0)
ksi_true  = Expression("0.0", degree=2, t=0.0)

f         = Expression(("0.0","0.0"), degree=2, t=0.0)
g         = Expression("0.0", degree=2, t=0.0)

w1_0      = Expression(("0.0","0.0","0.0"), degree=2, t=0.0)
p_0       = Expression("0.0", degree=2, t=0.0)
w_0       = Expression(("0.0","0.0","0.0","0.0"), degree=2, t=0.0)

def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

def boundary_u2(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

def boundary_u1(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

def boundary_p(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

# Here we try to use the Coupled algorithm to solve the Barry-Mercer's Problem
Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)

bc1c1 = DirichletBC(Qc.sub(0).sub(0), 0.0, boundary_u1)
bc1c2 = DirichletBC(Qc.sub(0).sub(1), 0.0, boundary_u2)
bc2c = DirichletBC(Qc.sub(2), 0.0, boundary_p)
bcc  = [bc1c1, bc1c2, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2.0*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1.0/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + alpha*alpha/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution

t = 0.0
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    A_ass, b_ass = assemble_system(lhs(Fc), rhs(Fc), bcc)

    ps = PointSource(Qc.sub(2), Point(0.25,0.25), 2*beta*np.sin(beta*t))
    ps.apply(b_ass)

    solve(A_ass, wc.vector(), b_ass)
    
    w_oldc.assign(wc)
    
(uc, ksic, pc) = wc.split(True)
# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(pc)

pic = plot(uc)
pyplot.colorbar(pic)

print(np.max(pc.vector().get_local()))

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values1.append(pc(Point(0.036,yy)))
    y_values2.append(pc(Point(0.107,yy)))
    y_values3.append(pc(Point(0.179,yy)))
    y_values4.append(pc(Point(0.250,yy)))

fig, ax = plt.subplots()
plt.plot(x_values, y_values1, 'o-', label='$y=0.036$')
plt.plot(x_values, y_values2, '*-', label='$y=0.107$')
plt.plot(x_values, y_values3, '^-', label='$y=0.179$')
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()

print(y_values4)
t = 1.5707963267948966e-09
t = 3.141592653589793e-09
7.14160098387084e-10


[-1.9656650611508587e-36, 1.9688695028620945e-20, 8.876470873224048e-20, 1.7058019924306168e-19, 3.316484743007276e-19, 6.728062377593347e-19, 1.4746901053455463e-18, 3.767809072668875e-18, 1.3251474488774226e-17, 6.064794896501848e-17, 3.026367456597209e-16, 3.379375782087593e-15, 4.158101431965675e-14, 1.8197417512017554e-13, 1.0964867424714838e-13, 3.667636887257815e-11, 7.14160098387084e-10, 3.667636887233611e-11, 1.0964867377843451e-13, 1.8197417445530025e-13, 4.158101350794855e-14, 3.379374895446569e-15, 3.0263588478532696e-16, 6.064725263157632e-17, 1.3251133319992414e-17, 3.7680859287243456e-18, 1.475948624654253e-18, 6.755394777100142e-19, 3.3645444518135236e-19, 1.77905062046747e-19, 9.86833113478596e-20, 5.701685557601822e-20, 3.413506479318999e-20, 2.1085853900249387e-20, 1.3390945445554968e-20, 8.715835969955858e-21, 5.798313940191686e-21, 3.93319906297373e-21, 2.7146761066755863e-21, 1.9028315940691565e-21, 1.3522964489492063e-21, 9.729664823775117e-22, 7.078189682451619e-22, 5.200511290999107e-22, 3.8548740388599903e-22, 2.879689543730949e-22, 2.165220449981667e-22, 1.6358210450257609e-22, 1.238509073571495e-22, 9.356692679943634e-23, 7.001379760228322e-23, 5.119775191272802e-23, 3.5623949474290815e-23, 2.2146991409633295e-23, 9.864176649675919e-24, -1.960809975556305e-24, -1.395028782912251e-23, -2.6653185725364605e-23, -4.0572409176304733e-23, -5.617996934329148e-23, -7.39232986212548e-23, -9.442634787124421e-23, -1.230875293006116e-22, -3.000292759328553e-22, -6.469398175018658e-38]
In [69]:
"""This demo program solves the three-field Biot's equation (Decoupled StR)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
import numpy as np
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model

dim     = 2
alpha   = 1.0
c0      = 0.0
KK      = 1e-6
E       = 1e5
nu      = 0.1
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)
beta    = (lmbda + 2*mu)*KK

T       = np.pi*1e-9
stepnum = 2
dt      = T/stepnum


# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true    = Expression(("0.0","0.0"), degree=3, t=0.0)
u1_true   = Expression("0.0", degree=3, t=0.0)
u2_true   = Expression("0.0", degree=3, t=0.0)
p_true    = Expression("0.0", degree=2, t=0.0)
ksi_true  = Expression("0.0", degree=2, t=0.0)

f         = Expression(("0.0","0.0"), degree=2, t=0.0)
g         = Expression("0.0", degree=2, t=0.0)

w1_0      = Expression(("0.0","0.0","0.0"), degree=2, t=0.0)
p_0       = Expression("0.0", degree=2, t=0.0)
w_0       = Expression(("0.0","0.0","0.0","0.0"), degree=2, t=0.0)

def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

def boundary_u2(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

def boundary_u1(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

def boundary_p(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

bc111 = DirichletBC(Q1.sub(0).sub(0), 0.0, boundary_u1)
bc112 = DirichletBC(Q1.sub(0).sub(1), 0.0, boundary_u2)
bc11 = [bc111, bc112]
bc22 = DirichletBC(Q2, p_true, boundary_p)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2StR = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_,phi)*dx + alpha/lmbda*inner(p_old-p_oldold,phi)*dx
# a3 = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_-ksi_old,psi)*dx + 0.5*KK*inner(grad(p)+grad(p_old),grad(psi))*dx

L1 = inner(f, v)*dx
L2 = inner(g, psi)*dx

F1  = a1 + a2StR - L1
a11, L11 = lhs(F1), rhs(F1)

F2  = a3 - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c1 = DirichletBC(Qc.sub(0).sub(0), 0.0, boundary_u1)
bc1c2 = DirichletBC(Qc.sub(0).sub(1), 0.0, boundary_u2)
bc2c = DirichletBC(Qc.sub(2), 0.0, boundary_p)
bcc  = [bc1c1, bc1c2, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
# solve(ac == Lc, wc, bcc)
A_ass, b_ass = assemble_system(ac, Lc, bcc)
ps = PointSource(Qc.sub(2), Point(0.25,0.25), 2*beta*np.sin(beta*t))
ps.apply(b_ass)
solve(A_ass, wc.vector(), b_ass)
    
(uc, ksic, pc) = wc.split(True)

(u_,ksi_) = w1_.split()
ksi_.assign(ksic)
p_old.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_.assign(w1)
    
    A_ass1, b_ass1 = assemble_system(a22, L22, bc22)
    ps = PointSource(Q2, Point(0.25,0.25), 2*beta*np.sin(beta*t))
    ps.apply(b_ass1)
    solve(A_ass1, p.vector(), b_ass1)
    
    #solve(a22 == L22, p, bc22)
    #print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    p_oldold.assign(p_old)
    p_old.assign(p)
    
    w1_old.assign(w1)
    u, ksi = w1.split(True)
    
time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(pc)

pic = plot(uc)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
print(np.max(pc.vector().get_local()))

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values1.append(p(Point(0.036,yy)))
    y_values2.append(p(Point(0.107,yy)))
    y_values3.append(p(Point(0.179,yy)))
    y_values4.append(p(Point(0.250,yy)))

fig, ax = plt.subplots()
plt.plot(x_values, y_values1, 'o-', label='$y=0.036$')
plt.plot(x_values, y_values2, '*-', label='$y=0.107$')
plt.plot(x_values, y_values3, '^-', label='$y=0.179$')
plt.plot(x_values, y_values4, '+-', label='$y=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()

print(y_values4)
t = 3.141592653589793e-09
time cost 3.8725650310516357 s
2.3874294088707407e-12
2.380561622271169e-10


[-1.3103646370743867e-36, 1.312614745191611e-20, 5.917796628494788e-20, 1.1372704863747878e-19, 2.211460538960103e-19, 4.488936637375827e-19, 9.859625892275693e-19, 2.536876007216633e-18, 9.050782906164188e-18, 4.201020831798121e-17, 2.1380255295777325e-16, 2.3897669141532295e-15, 2.908727294212863e-14, 1.2796375035514365e-13, 1.0713922773697966e-13, 2.5917514473576804e-11, 5.020687566395427e-10, 2.5917514473415523e-11, 1.0713922742448877e-13, 1.2796374991187125e-13, 2.90872724009603e-14, 2.389766323017945e-15, 2.138019790083775e-16, 4.200974406857093e-17, 9.05055543722722e-18, 2.537060559926798e-18, 9.86801593383607e-19, 4.507158274424882e-19, 2.2435005514305773e-19, 1.1861032466658244e-19, 6.579041522789307e-20, 3.8011830541534063e-20, 2.2757026748521673e-20, 1.405742655657027e-20, 8.92741706218518e-21, 5.810636222399059e-21, 3.865595978970067e-21, 2.6221697293201005e-21, 1.8098103404162073e-21, 1.26857450147501e-21, 9.015460045688778e-22, 6.486561520347123e-22, 4.718880701857835e-22, 3.467081074228112e-22, 2.5699798077730616e-22, 1.919847743173528e-22, 1.4435278538669914e-22, 1.0905813988189793e-22, 8.2570318278535e-23, 6.238034710317002e-23, 4.667805875507131e-23, 3.4133403915819656e-23, 2.375098355297645e-23, 1.476584407026901e-23, 6.5772148116526406e-24, -1.3063705724821694e-24, -9.299584996249416e-24, -1.7768538599268354e-23, -2.7048055542211827e-23, -3.7453471933130056e-23, -4.9282534863807383e-23, -6.29515608352384e-23, -8.205948087215434e-23, -2.000214093253059e-22, -4.312999919997892e-38]
In [67]:
"""This demo program solves the three-field Biot's equation (Decoupled RtS)

Example 1. 

data 2023 07 01
"""

from dolfin import *
import time
import numpy as np
set_log_level(40)

time_start = time.time()

# Parameters for Biot's model

dim     = 2
alpha   = 1.0
c0      = 0.0
KK      = 1e-6
E       = 1e5
nu      = 0.1
mu      = E/2/(1+nu)
lmbda   = E*nu/(1+nu)/(1-2*nu)
beta    = (lmbda + 2*mu)*KK

T       = np.pi*1e-9
stepnum = 2
dt      = T/stepnum

'''
alpha   = 1.0
c0      = 0.0
KK      = 1.0
mu      = 0.4
lmbda   = 0.2
beta    = 1.0
T       = np.pi/2
stepnum = 20
dt      = T/stepnum
'''
# Create mesh on [0,1]*[0,1]
nx = ny = 64
mesh = UnitSquareMesh(nx, ny)

# Define function spaces (P2-P1-P1)
V = VectorElement("CG", mesh.ufl_cell(), 3)
W = FiniteElement("CG", mesh.ufl_cell(), 2)
M = FiniteElement("CG", mesh.ufl_cell(), 2)

Q1 = FunctionSpace(mesh, MixedElement([V, W]))
Q2 = FunctionSpace(mesh, M)


# Define trial and test functions
w1          = TrialFunction(Q1)
u, ksi      = split(w1)
p           = TrialFunction(Q2)

v, phi      = TestFunctions(Q1)
psi         = TestFunction(Q2)

# Define boundary conditions
u_true    = Expression(("0.0","0.0"), degree=3, t=0.0)
u1_true   = Expression("0.0", degree=3, t=0.0)
u2_true   = Expression("0.0", degree=3, t=0.0)
p_true    = Expression("0.0", degree=2, t=0.0)
ksi_true  = Expression("0.0", degree=2, t=0.0)

f         = Expression(("0.0","0.0"), degree=2, t=0.0)
g         = Expression("0.0", degree=2, t=0.0)

w1_0      = Expression(("0.0","0.0","0.0"), degree=2, t=0.0)
p_0       = Expression("0.0", degree=2, t=0.0)
w_0       = Expression(("0.0","0.0","0.0","0.0"), degree=2, t=0.0)

def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

def boundary_u2(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

def boundary_u1(x):
    return x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

def boundary_p(x):
    return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS or x[1] < DOLFIN_EPS or x[1] > 1.0 - DOLFIN_EPS

bc111 = DirichletBC(Q1.sub(0).sub(0), 0.0, boundary_u1)
bc112 = DirichletBC(Q1.sub(0).sub(1), 0.0, boundary_u2)
bc11 = [bc111, bc112]
bc22 = DirichletBC(Q2, p_true, boundary_p)

w1_oldold = interpolate(w1_0,Q1)
w1_old    = interpolate(w1_0,Q1)
w1_       = interpolate(w1_0,Q1)
p_oldold  = interpolate(p_0,Q2)
p_old     = interpolate(p_0,Q2)
p_        = interpolate(p_0,Q2)

u_oldold, ksi_oldold = split(w1_oldold)
u_old, ksi_old = split(w1_old)
u_   , ksi_    = split(w1_)


# Define the weak formulation
def epsilon(u):
    return 0.5*(nabla_grad(u) + nabla_grad(u).T)

a1 = 2*mu*inner(epsilon(u), epsilon(v))*dx - inner(ksi,div(v))*dx
a2 = - inner(div(u),phi)*dx - 1.0/lmbda*inner(ksi,phi)*dx + alpha/lmbda*inner(p_old,phi)*dx
a3RtS = (c0 + 1/lmbda)/dt*inner(p-p_old,psi)*dx - alpha/lmbda/dt*inner(ksi_old-ksi_oldold,psi)*dx + KK*inner(grad(p),grad(psi))*dx

a2RtS = - inner(div(u-u_old),phi)*dx - 1.0/lmbda*inner(ksi-ksi_old,phi)*dx + alpha/lmbda*inner(p_-p_old,phi)*dx

L1 = inner(f, v)*dx
L2 = inner(g, psi)*dx

F1 = a1 + a2RtS- L1
a11, L11 = lhs(F1), rhs(F1)

F2 = a3RtS - L2
a22, L22 = lhs(F2), rhs(F2)

# Time-stepping for Biot's problem
w1 = Function(Q1)
p  = Function(Q2)
t = 0.0

# The first step is different
t = dt

Qc = FunctionSpace(mesh, MixedElement([V, W, M]))
    
wc             = TrialFunction(Qc)
uc, ksic, pc   = split(wc)
vc, phic, psic = TestFunctions(Qc)
    
bc1c1 = DirichletBC(Qc.sub(0).sub(0), 0.0, boundary_u1)
bc1c2 = DirichletBC(Qc.sub(0).sub(1), 0.0, boundary_u2)
bc2c = DirichletBC(Qc.sub(2), 0.0, boundary_p)
bcc  = [bc1c1, bc1c2, bc2c]
   
w_oldc                   = interpolate(w_0,Qc)
u_oldc, ksi_oldc, p_oldc = split(w_oldc)
    
a1c = 2*mu*inner(epsilon(uc), epsilon(vc))*dx - inner(ksic,div(vc))*dx
a2c = - inner(div(uc),phic)*dx - 1/lmbda*inner(ksic,phic)*dx + alpha/lmbda*inner(pc,phic)*dx
a3c = (c0 + 1/lmbda)/dt*inner(pc-p_oldc,psic)*dx - alpha/lmbda/dt*inner(ksic-ksi_oldc,psic)*dx + KK*inner(grad(pc),grad(psic))*dx
 
L1c = inner(f, vc)*dx
L2c = inner(g, psic)*dx
    
Fc  = a1c + a2c + a3c - L1c - L2c
ac, Lc = lhs(Fc), rhs(Fc)
    
wc = Function(Qc)
# Compute solution
# solve(ac == Lc, wc, bcc)
A_ass, b_ass = assemble_system(ac, Lc, bcc)
ps = PointSource(Qc.sub(2), Point(0.25,0.25), 2*beta*np.sin(beta*t))
ps.apply(b_ass)
solve(A_ass, wc.vector(), b_ass)
    
(uc, ksic, pc) = wc.split(True)

(u_,ksi_) = w1_.split()
(u_old,ksi_old) = w1_old.split()
ksi_old.assign(ksic)
p_old.assign(pc)
p_.assign(pc)
while t < T - dt/5.0:    
    t += dt
    print("t =", t)
    
    # solve(a22 == L22, p, bc22)
    # print("p_old:",norm(p_old,'L2'),"p:",norm(p,'L2'))   
    A_ass1, b_ass1 = assemble_system(a22, L22, bc22)
    ps = PointSource(Q2, Point(0.25,0.25), 2*beta*np.sin(beta*t))
    ps.apply(b_ass1)
    solve(A_ass1, p.vector(), b_ass1)
    
    p_.assign(p)
    
    # Compute solution
    solve(a11 == L11, w1, bc11)
    w1_oldold.assign(w1_old)
    w1_old.assign(w1)
    
    p_old.assign(p)
    u, ksi = w1.split(True)
    
time_end = time.time()    
print('time cost',time_end - time_start,'s')

# Visualisation
from matplotlib import pyplot

#p = w2.split(True)
plot(pc)

# pic = plot(uc)
pyplot.colorbar(pic)

error_L2_p  = errornorm(p_true, p, 'L2')
error_H1_p  = errornorm(p_true, p, 'H1')

#print('error_L2_p  =', error_L2_p)
#print('error_H1_p  =', error_H1_p)

print(norm(p,'L2'))
print(np.max(pc.vector().get_local()))

print(np.max(pc.vector().get_local()))

import matplotlib.pyplot as plt
x_values = []
y_values1, y_values2, y_values3, y_values4 = [], [], [], []
for i in range((nx+1)):
    x_values.append(i/(1.0*nx))
    yy = i/(1.0*nx) 
    y_values1.append(p(Point(0.036,yy)))
    y_values2.append(p(Point(0.107,yy)))
    y_values3.append(p(Point(0.179,yy)))
    y_values4.append(p(Point(0.250,yy)))

fig, ax = plt.subplots()
plt.plot(x_values, y_values1, 'o-', label='$x=0.036$')
plt.plot(x_values, y_values2, '*-', label='$x=0.107$')
plt.plot(x_values, y_values3, '^-', label='$x=0.179$')
plt.plot(x_values, y_values4, '+-', label='$x=0.250$')

plt.gcf().set_size_inches(8, 3)
plt.legend(loc=0)
plt.show()

print(y_values4)
t = 3.141592653589793e-09
Calling FFC just-in-time (JIT) compiler, this may take some time.
Calling FFC just-in-time (JIT) compiler, this may take some time.
time cost 4.247470378875732 s
1.3787452270171934e-12
2.380561622271169e-10
2.380561622271169e-10


[-6.551914170678826e-37, 6.563176293564886e-21, 2.958989494106149e-20, 5.687138448832188e-20, 1.1063860916305417e-19, 2.249696765548249e-19, 4.972033351238711e-19, 1.3058133227662635e-18, 4.849130757121867e-18, 2.336646861241e-17, 1.2494958274214962e-16, 1.3999158187259067e-15, 1.6589787526677643e-14, 7.394176495513786e-14, 1.0469042413128022e-13, 1.5157782425778808e-11, 2.899699305796945e-10, 1.515778242569817e-11, 1.0469042397503125e-13, 7.39417647334951e-14, 1.6589787256085687e-14, 1.399915523148829e-15, 1.2494929575758407e-16, 2.3366236477244894e-17, 4.849017012490874e-18, 1.3059055888336425e-18, 4.976228274700744e-19, 2.2588074907070596e-19, 1.1224060162290597e-19, 5.931301675535351e-20, 3.2896117776697993e-20, 1.9006006700629085e-20, 1.1378512188980763e-20, 7.028705359962e-21, 4.463702783233861e-21, 2.9053144909282693e-21, 1.9327959166515048e-21, 1.3110837920089755e-21, 9.049047999228468e-22, 6.3428735243371175e-22, 4.50773439225148e-22, 3.243286860985458e-22, 2.3594477657144026e-22, 1.7335483031770618e-22, 1.2849980207686046e-22, 9.59931818045731e-23, 7.217717053267545e-23, 5.452978825703702e-23, 4.1285838607761506e-23, 3.119078228223665e-23, 2.3339584781520505e-23, 1.706719238018749e-23, 1.1875952867714589e-23, 7.383314518009303e-24, 3.28897050655488e-24, -6.528722173031926e-25, -4.649506652071632e-24, -8.884024552656326e-24, -1.3523796344948906e-23, -1.872654101072931e-23, -2.4641076868310788e-23, -3.147561292490006e-23, -4.10295595848495e-23, -1.0001048522176029e-22, -2.1564937642374216e-38]
In [71]:
# This is for Example 3

x_values   = [0.0, 0.015625, 0.03125, 0.046875, 0.0625, 0.078125, 0.09375, 0.109375, 0.125, 0.140625, 0.15625, 0.171875, 0.1875, 0.203125, 0.21875, 0.234375, 0.25, 0.265625, 0.28125, 0.296875, 0.3125, 0.328125, 0.34375, 0.359375, 0.375, 0.390625, 0.40625, 0.421875, 0.4375, 0.453125, 0.46875, 0.484375, 0.5, 0.515625, 0.53125, 0.546875, 0.5625, 0.578125, 0.59375, 0.609375, 0.625, 0.640625, 0.65625, 0.671875, 0.6875, 0.703125, 0.71875, 0.734375, 0.75, 0.765625, 0.78125, 0.796875, 0.8125, 0.828125, 0.84375, 0.859375, 0.875, 0.890625, 0.90625, 0.921875, 0.9375, 0.953125, 0.96875, 0.984375, 1.0]

p_coupled  = [-1.9656650611508587e-36, 1.9688695028620945e-20, 8.876470873224048e-20, 1.7058019924306168e-19, 3.316484743007276e-19, 6.728062377593347e-19, 1.4746901053455463e-18, 3.767809072668875e-18, 1.3251474488774226e-17, 6.064794896501848e-17, 3.026367456597209e-16, 3.379375782087593e-15, 4.158101431965675e-14, 1.8197417512017554e-13, 1.0964867424714838e-13, 3.667636887257815e-11, 7.14160098387084e-10, 3.667636887233611e-11, 1.0964867377843451e-13, 1.8197417445530025e-13, 4.158101350794855e-14, 3.379374895446569e-15, 3.0263588478532696e-16, 6.064725263157632e-17, 1.3251133319992414e-17, 3.7680859287243456e-18, 1.475948624654253e-18, 6.755394777100142e-19, 3.3645444518135236e-19, 1.77905062046747e-19, 9.86833113478596e-20, 5.701685557601822e-20, 3.413506479318999e-20, 2.1085853900249387e-20, 1.3390945445554968e-20, 8.715835969955858e-21, 5.798313940191686e-21, 3.93319906297373e-21, 2.7146761066755863e-21, 1.9028315940691565e-21, 1.3522964489492063e-21, 9.729664823775117e-22, 7.078189682451619e-22, 5.200511290999107e-22, 3.8548740388599903e-22, 2.879689543730949e-22, 2.165220449981667e-22, 1.6358210450257609e-22, 1.238509073571495e-22, 9.356692679943634e-23, 7.001379760228322e-23, 5.119775191272802e-23, 3.5623949474290815e-23, 2.2146991409633295e-23, 9.864176649675919e-24, -1.960809975556305e-24, -1.395028782912251e-23, -2.6653185725364605e-23, -4.0572409176304733e-23, -5.617996934329148e-23, -7.39232986212548e-23, -9.442634787124421e-23, -1.230875293006116e-22, -3.000292759328553e-22, -6.469398175018658e-38]
p_StR      = [-1.3103646370743867e-36, 1.312614745191611e-20, 5.917796628494788e-20, 1.1372704863747878e-19, 2.211460538960103e-19, 4.488936637375827e-19, 9.859625892275693e-19, 2.536876007216633e-18, 9.050782906164188e-18, 4.201020831798121e-17, 2.1380255295777325e-16, 2.3897669141532295e-15, 2.908727294212863e-14, 1.2796375035514365e-13, 1.0713922773697966e-13, 2.5917514473576804e-11, 5.020687566395427e-10, 2.5917514473415523e-11, 1.0713922742448877e-13, 1.2796374991187125e-13, 2.90872724009603e-14, 2.389766323017945e-15, 2.138019790083775e-16, 4.200974406857093e-17, 9.05055543722722e-18, 2.537060559926798e-18, 9.86801593383607e-19, 4.507158274424882e-19, 2.2435005514305773e-19, 1.1861032466658244e-19, 6.579041522789307e-20, 3.8011830541534063e-20, 2.2757026748521673e-20, 1.405742655657027e-20, 8.92741706218518e-21, 5.810636222399059e-21, 3.865595978970067e-21, 2.6221697293201005e-21, 1.8098103404162073e-21, 1.26857450147501e-21, 9.015460045688778e-22, 6.486561520347123e-22, 4.718880701857835e-22, 3.467081074228112e-22, 2.5699798077730616e-22, 1.919847743173528e-22, 1.4435278538669914e-22, 1.0905813988189793e-22, 8.2570318278535e-23, 6.238034710317002e-23, 4.667805875507131e-23, 3.4133403915819656e-23, 2.375098355297645e-23, 1.476584407026901e-23, 6.5772148116526406e-24, -1.3063705724821694e-24, -9.299584996249416e-24, -1.7768538599268354e-23, -2.7048055542211827e-23, -3.7453471933130056e-23, -4.9282534863807383e-23, -6.29515608352384e-23, -8.205948087215434e-23, -2.000214093253059e-22, -4.312999919997892e-38]
p_RtS      = [-6.551914170678826e-37, 6.563176293564886e-21, 2.958989494106149e-20, 5.687138448832188e-20, 1.1063860916305417e-19, 2.249696765548249e-19, 4.972033351238711e-19, 1.3058133227662635e-18, 4.849130757121867e-18, 2.336646861241e-17, 1.2494958274214962e-16, 1.3999158187259067e-15, 1.6589787526677643e-14, 7.394176495513786e-14, 1.0469042413128022e-13, 1.5157782425778808e-11, 2.899699305796945e-10, 1.515778242569817e-11, 1.0469042397503125e-13, 7.39417647334951e-14, 1.6589787256085687e-14, 1.399915523148829e-15, 1.2494929575758407e-16, 2.3366236477244894e-17, 4.849017012490874e-18, 1.3059055888336425e-18, 4.976228274700744e-19, 2.2588074907070596e-19, 1.1224060162290597e-19, 5.931301675535351e-20, 3.2896117776697993e-20, 1.9006006700629085e-20, 1.1378512188980763e-20, 7.028705359962e-21, 4.463702783233861e-21, 2.9053144909282693e-21, 1.9327959166515048e-21, 1.3110837920089755e-21, 9.049047999228468e-22, 6.3428735243371175e-22, 4.50773439225148e-22, 3.243286860985458e-22, 2.3594477657144026e-22, 1.7335483031770618e-22, 1.2849980207686046e-22, 9.59931818045731e-23, 7.217717053267545e-23, 5.452978825703702e-23, 4.1285838607761506e-23, 3.119078228223665e-23, 2.3339584781520505e-23, 1.706719238018749e-23, 1.1875952867714589e-23, 7.383314518009303e-24, 3.28897050655488e-24, -6.528722173031926e-25, -4.649506652071632e-24, -8.884024552656326e-24, -1.3523796344948906e-23, -1.872654101072931e-23, -2.4641076868310788e-23, -3.147561292490006e-23, -4.10295595848495e-23, -1.0001048522176029e-22, -2.1564937642374216e-38]

# The first is p

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, p_coupled, 'o-', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, p_StR    , 's--', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, p_RtS    , '^--', label='RtS algorithm',     markerfacecolor='none')

ax.set_xlabel('y',labelpad=-10,size=14,)
ax.set_ylabel('pressure $p$',labelpad=1,size=14,)
ax.set_title('The Second Time Step')
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(8, 4)
plt.xlim((0.0,1.0))
plt.legend(loc=0, prop = {'size':11})
plt.savefig("./BMPS.eps",dpi=600)
plt.show()
The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.

In [68]:
# This is for Example 3

x_values   = [0.0, 0.015625, 0.03125, 0.046875, 0.0625, 0.078125, 0.09375, 0.109375, 0.125, 0.140625, 0.15625, 0.171875, 0.1875, 0.203125, 0.21875, 0.234375, 0.25, 0.265625, 0.28125, 0.296875, 0.3125, 0.328125, 0.34375, 0.359375, 0.375, 0.390625, 0.40625, 0.421875, 0.4375, 0.453125, 0.46875, 0.484375, 0.5, 0.515625, 0.53125, 0.546875, 0.5625, 0.578125, 0.59375, 0.609375, 0.625, 0.640625, 0.65625, 0.671875, 0.6875, 0.703125, 0.71875, 0.734375, 0.75, 0.765625, 0.78125, 0.796875, 0.8125, 0.828125, 0.84375, 0.859375, 0.875, 0.890625, 0.90625, 0.921875, 0.9375, 0.953125, 0.96875, 0.984375, 1.0]

p_coupled  = [-1.330588225394674e-28, 4.1921827002857976e-13, 2.471994177256975e-12, 4.801170400249693e-12, 9.327635726272111e-12, 1.8725666081121327e-11, 3.968662677290169e-11, 9.03090872535778e-11, 2.246646464112171e-10, 6.31339392596333e-10, 2.4425048543510342e-09, 1.895044009146972e-08, 2.052877066653377e-07, 1.6798677680022052e-06, 1.659064889248732e-05, 0.0007874144969477654, 0.022699837226738625, 0.0007874144969409604, 1.6590648879301136e-05, 1.679867749302374e-06, 2.052876838474277e-07, 1.8950415189060683e-08, 2.442480716172133e-09, 6.313199449115956e-10, 2.2465528903840596e-10, 9.031729675634306e-11, 3.972288665476281e-11, 1.8804799558107028e-11, 9.469921892727831e-12, 5.028808654287169e-12, 2.795989900175658e-12, 1.6180845135134528e-12, 9.699069938779326e-13, 5.996872801283331e-13, 3.811090072992415e-13, 2.481833741079216e-13, 1.6516953165539486e-13, 1.1207059864869096e-13, 7.736520458232396e-14, 5.423543689132229e-14, 3.854691174857671e-14, 2.773553482389065e-14, 2.0177673465882575e-14, 1.4825154725290164e-14, 1.098916172378434e-14, 8.20920435771495e-15, 6.172538310752158e-15, 4.663493533871408e-15, 3.5311442669003115e-15, 2.668220158449087e-15, 1.9973295833019747e-15, 1.4616264909596074e-15, 1.0185625245740702e-15, 6.355218345714977e-16, 2.8683384376565654e-16, -4.842859611341226e-17, -3.879490663696905e-16, -7.473386234379247e-16, -1.1408844218066515e-15, -1.5822714487414222e-15, -2.0850341257095405e-15, -2.666126674096977e-15, -3.4545248361792614e-15, -9.336775211536803e-15, -1.789007496191789e-30]
p_StR      = [-8.516474641136921e-29, 3.2810862504244295e-13, 1.7875583977438552e-12, 3.464411982527399e-12, 6.728745504457863e-12, 1.3513749800423904e-11, 2.8691036477797862e-11, 6.580410169310954e-11, 1.6839245538523598e-10, 5.145865483166036e-10, 2.397979059370929e-09, 2.2010957360212534e-08, 2.4322432507016323e-07, 1.7147191105482429e-06, 1.3029294417410023e-05, 0.0006508758057814655, 0.016842527968563836, 0.0006508758057757199, 1.302929440626831e-05, 1.714719094725191e-06, 2.432243056936871e-07, 2.2010936042820232e-08, 2.397958013632434e-09, 5.145687646147808e-10, 1.6838197558914711e-10, 6.580644466064645e-11, 2.8713852953082466e-11, 1.356773276530571e-11, 6.828244308666726e-12, 3.6243873735171388e-12, 2.01435793345434e-12, 1.1653618371605494e-12, 6.983803848166438e-13, 4.317781065888152e-13, 2.7445427967689514e-13, 1.7883035298157765e-13, 1.1914365892393454e-13, 8.098423440259065e-14, 5.605220657133915e-14, 3.943803541662619e-14, 2.8166131146647302e-14, 2.0392322747780627e-14, 1.494991130751308e-14, 1.1086475121586595e-14, 8.30818020016829e-15, 6.285356249943397e-15, 4.7944546171969725e-15, 3.6815486845210166e-15, 2.8390262828573885e-15, 2.1905311771880255e-15, 1.6809729877204174e-15, 1.2699010898586201e-15, 9.270163621472523e-16, 6.290308292344395e-16, 3.5759496336349366e-16, 9.767671797758348e-17, -1.6345631715046657e-16, -4.370680436924869e-16, -7.335464603450354e-16, -1.062758415687205e-15, -1.4345009012865635e-15, -1.861032781730304e-15, -2.436537815662786e-15, -6.5350027645002726e-15, -1.2796686306167096e-30]
p_RtS      = [-4.2629134718217937e-29, 1.6171190251900158e-13, 8.853792625996836e-13, 1.7173147684515235e-12, 3.3364895544115685e-12, 6.706950336272674e-12, 1.429440518883042e-11, 3.3297141349821507e-11, 8.965507592303346e-11, 3.045028173354306e-10, 1.607423697301312e-09, 1.572015106852882e-08, 1.700689633182731e-07, 1.140179000280079e-06, 8.549493743214083e-06, 0.00039899756887273825, 0.009876245684745256, 0.00039899756886945453, 8.549493736843291e-06, 1.1401789912215838e-06, 1.700689521939609e-07, 1.572013875302579e-08, 1.6074113695223436e-09, 3.0449204260850123e-10, 8.964793644836871e-11, 3.329644317539832e-11, 1.4304002407797444e-11, 6.73220600358187e-12, 3.38462155245217e-12, 1.7959880615659501e-12, 9.980351244968836e-13, 5.773372195864096e-13, 3.459757177379196e-13, 2.1392088200401329e-13, 1.3601886329272288e-13, 8.86870030944503e-14, 5.915583062975996e-14, 4.0283294780700884e-14, 2.795626835799283e-14, 1.9742372303098947e-14, 1.4167993949681891e-14, 1.0320380957084654e-14, 7.622564062077015e-15, 5.702824760129981e-15, 4.3175035517693115e-15, 3.304163811327279e-15, 2.5528286617148558e-15, 1.9878816424075005e-15, 1.5565327020538088e-15, 1.221362169039378e-15, 9.553888481523057e-16, 7.387972324068796e-16, 5.567325118630115e-16, 3.977527594285218e-16, 2.528202163871811e-16, 1.1450090068941808e-16, -2.3522712800401117e-17, -1.6686347090067672e-16, -3.2071367081703144e-16, -4.900211375995376e-16, -6.797149661379956e-16, -8.958994492827763e-16, -1.1843405036294302e-15, -3.2219409564964927e-15, -6.2835384393522505e-31]

# The first is p

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
plt.plot(x_values, p_coupled, 'o-', label='Coupled algorithm', markerfacecolor='none')
plt.plot(x_values, p_StR    , 's--', label='StR algorithm',     markerfacecolor='none')
plt.plot(x_values, p_RtS    , '^--', label='RtS algorithm',     markerfacecolor='none')

ax.set_xlabel('y',labelpad=-10,size=14,)
ax.set_ylabel('pressure $p$',labelpad=1,size=14,)
ax.set_title('The Second Time Step')
ax.ticklabel_format(style='sci', scilimits=(-1,2), axis='y')

plt.gcf().set_size_inches(8, 4)
plt.xlim((0.0,1.0))
plt.legend(loc=0, prop = {'size':11})
plt.savefig("./BMPS.eps",dpi=600)
plt.show()
The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.


 